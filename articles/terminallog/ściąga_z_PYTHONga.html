<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8" />
			<link rel="icon" type="image/png" href="https://files.morketsmerke.net/resources/mm.png">
			<style>
				.code-block {
					display: block;
					background-color: silver;
					font-family: monospace;
					font-weight: bolder;
					text-align: left;
				}
				.code-inline {
					background-color: silver;
					font-family: monospace;
					font-weight: bolder;
				}
				ul {
					text-align: left;
				}
			</style>
		</head>
		<body style="font-family: monospace;" >
<pre>
 _                      _             _ _
| |_ ___ _ __ _ __ ___ (_)_ __   __ _| | | ___   __ _
| __/ _ \ '__| '_ ` _ \| | '_ \ / _` | | |/ _ \ / _` |
| ||  __/ |  | | | | | | | | | | (_| | | | (_) | (_| |
 \__\___|_|  |_| |_| |_|_|_| |_|\__,_|_|_|\___/ \__, |
			                        |___/
</pre>
<p style="margin: 0; padding: 0; outline: 0; font-size: 18pt;">
	&#9760;&nbsp;<a href="https://morketsmerke.net">morketsmerke</a>&nbsp;&#9760;
</p>
	<div style="margin-left: auto; margin-right: auto; text-align: justify; width:80%; ">
		<h1 style="text-align: center;">Ściąga z PYTHONga</h1>
		<h2>Wprowadzenie</h2>
		<p>
			Informacje zawarte tutaj odnoszą się do wersji Pythona powyżej 3.6. Python powinien być zainstalowany domyślnie we wiodących dystrybucjach systemu Linux. Jeśli nie ma w ogóle Pythona w wersji &gt;= 3. To warto sprawdzić czy istnieją pakiety w repozytorium dystrybucji z wersją powyżej 3.6. jeśli tak to instalujemy te pakiety. Jeśli nie, to wtedy należałoby pobrać kod źródłowy najnowszego Pythona i go skompilować. Zazwyczaj nie kompiluje, ale w przypadku kiedy użyłem dystrybucji BunsenLabs Helium, to pre-instalowanego Pythona miałem w wersji 3.5. Za mało na najnowszy "Crash Course". Kompilacje wykonujemy w następujących krokach
		</p>
		<ol>
			<li>Instalujemy odpowiednie dla naszej dystrybucji <em>build-essential</em> oraz dwa pakiety których nieobecność została zauważona przy wykonywaniu polecenia <code class="code-inline">make altinstall</code> i zwrócona jako błąd, mianowicie chodzi o <em>zlib1g</em> oraz <em>zlib1g-dev</em>.</li>
			<li>Pobieramy najnowszą wersję kodu z https://www.python.org/ftp/python/3.8.3/Python-3.8.3.tar.xz</li>
			<li>Rozpakowujemy: <code class="code-inline">tar -xvf Python-3.8.3.tar.xz</code></li>
			<li>Przechodzimy do katalogu: <code class="code-inline">cd Python-3.8.3.tar.xz</code></li>
			<li>Ja w swoim systemie zachowałem obecną wersję Pythona, wskazując skryptowi konfiguracyjnemu opcje <code class="code-inline">prefix</code> wskazującą na katalog utworzony w moim katalogu domowym. <code class="code-inline">./configure --prefix="/home/xf0r3m/bin/python3.8"</code>. Użycie opcji <code class="code-inline">prefix</code>, przekazuje skryptowi, aby przygotował środowisko do kompilacji względem podanej ścieżki. Jeśli nie zostanie zwrócony żaden błąd podczas pracy skryptu, zostanie nam wygenerowany tzw. plik <em>makefile</em>.</li>
			<li>Wydajemy polecenie kompilacji kodu. <code class="code-inline">make</code>. Po poprawnie zakończonej kompilacji, to znaczy po wyświetlonych przez polecenie <code class="code-inline">make</code> następnych kompilacjach, zostanie nam  zwrócony <em>prompt</em>, możemy przejść do ostatniej części kompilacji czyli instalacji pakietu w systemie, z racji tego iż zostawiłem pre-instalowaną wersję 3.5, wydaje polecenie '<code class="code-inline">make altinstall</code> po wykonaniu tego polecenia nasz Python 3.8 znajduje się w podkatalogu <em>bin</em><span style="text-decoration: underline;"></span> na ścieżce, którą podaliśmy w opcji <code class="code-inline">prefix</code>. </li>
			<li>Ostatni punkt dla wygodnych, w pliku <em>.bashrc</em> możemy sobie zdefiniować alias <em>python</em> dla naszego nowo zainstalowanego Pythona.  Po uruchomieniu polecenia <code class="code-inline">python</code> powiśmy zobaczyć <em>prompt</em> powłoki wraz z informacjami odnośnie wersji. </li>
		</ol>
<pre class="code-block">
Python 3.8.2 (default, Apr 27 2020, 15:53:34)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre>
		<p>
			Poniżej znajdują się zagadnienia z książki które warto mieć przy sobie przy pierwszych projektach tworzonych w tym języku. Kolejność jest identyczna w kolejnością występowania w książce.
		</p>
		<p>
			<strong>print()</strong> - polecenie wyświetlające wszystko co umieścimy pomiędzy nawiasami.
		</p>
		<p>
			Konwencja nadawania wartości zmiennym w Pythonie wygląda w ten sposób. 'greetinsg_message = "Hello, World!"'. Warto pamiętać o spacjach pomiędzy operatorem. Podobnie zresztą wygląda konwencja stosowania jakichkolwiek operatorów.
		</p>
		<p>
			<strong>Ciągi tekstowe <em>f</em> </strong>- formatowane ciągi tekstowe. Litera f pochodzi od słowa <em>format</em>, ich głównym zadaniem jest zamiana nawiasu klamrowego wraz z nazwą zmiennej na jej wartość w ciągu. Taki ciąg tworzy się w następujący sposób:
		</p>
<pre class="code-block">
imie = 'xf0r3m'
print(f"Witaj {imie}! Czy chcesz zanurzyć się w świat Pythona?")
</pre>
		<p>
			Czy w innej zmiennej czy poleceniu <code class="code-inline">print()</code> zapisanie litery <code class="code-inline">f</code> przed znakami cudzysłowu lub apostrofu, spowoduje że dany ciąg będzie <em>ciągiem f</em>. <strong>Uwaga!</strong> <em>Ciągi f</em> są dostępne dopiero od wersji 3.6.
		</p>
		<p>
			<strong>Formatowanie ciągu przed wersją Pythona 3.6.</strong> Takie formatowanie polega na użyciu wbudowanej metody <strong>format()</strong>. Przykład poniżej.
		</p>
<pre class="code-block">
imie = 'xf0r3m'
print("Witaj {}! Czy chcesz zanurzyć się w świat Pythona?".format(imie))
</pre>
		<p>
			Dodatkowa zmienna do wyświetlenia, to dodatkowa para nawiasów i kolejna zmienna jako argument metody format.
		</p>
		<p>
			Do obróbki ciągów tekstowych, a konkretnie ich <strong>normalizacji</strong> mogą służyć nam poniższe metody:
		</p>
		<ul>
			<li><strong>title()</strong> - Zwraca ciąg tekstowy jak tytuł, czyli każdy wyraz w ciągu zaczyna się z wielkiej litery.</li>
			<li><strong>lower()</strong> - Zwraca ciąg tekstowy po całości zapisany małymi literami.</li>
			<li><strong>upper()</strong> - Zwraca ciąg tekstowy zapisany po całości z wielkich liter</li>
		</ul>
		<p>
			Warto zaznaczyć że te metody nie zmieniają wartości ciągu, o ile nie przypiszemy nie ich wartości zwrotnych.
		</p>
		<p>
			<strong>Białe znaki w ciągach tekstowych. </strong>Białe znaki w naszych ciągach uzyskuje się w bardzo prosty sposób, po prostu po przez umieszczenie w ciągu:
		</p>
		<ul>
			<li><strong>\t </strong> - tabulator</li>
			<li><strong>\n</strong> - znak nowej linii</li>
		</ul>
<pre class="code-block">
imie = 'xf0r3m'
print(f"Witaj \t{imie}!\nCzy chcesz zanurzyć się w świat Pythona?")
</pre>
		<p>
			<strong>Usuwanie białych znaków</strong>. Może zdarzyć się taka sytuacja że weźmie się skądś dane,  i nagle gdzieś nasz algorytm nie działa, bo ma nie prawidłowe dane. Gdzieś na początku albo na końcu ciągu znajdują się nadmiarowe białe znaki np. skopiowaliśmy jakiś ciąg ze spacją na końcu. To zresztą zdarza się dość często. W tym przypadku korzystamy z metody <code class="code-inline">strip()</code> jeśli nie potrafimy jasno określić czy z lewej lub prawej strony ciągu znajdują się nadmiarowe białe znaki. Dla znaków po lewej stronie możemy użyć <strong>lstrip() </strong>a dla znaków po prawej <strong>rstrip()</strong>. Warto mieć na uwadze że te metody <strong>nie dokonują w zmiennej żadnych zmian,</strong> <strong>aby zapisać zmiany musimy nadać zmiennej wartość zwracaną przez tą metodę</strong>
		</p>
<pre class="code-block">
dirty_strings='  python  '
washed_strings=dirty_strings.strip()
</pre>
		<p>
			Wielkie liczby możemy zapisywać za pomocą<strong> grup rozdzielonych przy pomocy znaku podkreślenia(_)</strong>, na przykład:
		</p>
<pre class="code-block">
one_bilion = 1_000_000_000
</pre>
		<p>
			Z poziomu Pythona nie ma znaczenia, czy jest 1000000000 czy <em>1_000_000_000</em>. Podobnie jest z mniejszymi liczbami, takimi jak 1000 (<em>1_000</em>). <strong>Uwaga! Ta funkcjonalność dostępna jest od Pythona 3.6 w górę. </strong>
		</p>
		<p>
			<strong>Wiele przypisań</strong> wartość możemy skrócić sobie do praktycznego, aczkolwiek nie zawsze czytelnego zapisu. Na przykład:
		</p>
<pre class="code-block">
x, y, z = 0, 0, 0
a, b, c = 3, 4, 5
</pre>
		<p>
			W Pythonie nie ma stałych, jednak wśród programistów nie tylko Pythona przyjęło się że każdą zmienną, której nazwa (identyfikator) będzie zapisany wielkimi literami traktuje się jako <strong>stałą</strong>.
		</p>
<pre class="code-block">
NIGGA_AM = 300
#BANG!
</pre>
		<p>
			<strong>Komentarze </strong>w Pythonie zaczynają się <strong>od</strong> <strong>znaku hash #</strong>. Wszystko co zostanie umieszczone po tym znaku zostanie zignorowane w przez interpreter Pythona.
		</p>
		<p>
			<strong>Zen Pythona </strong>- to kilka zasad stworzonych przez społeczność Pythona. Cenne uwagi, które warto wziąć sobie do serca programując nie tylko w Pythonie. Warto sobie zrobić z tego swoisty kodeks programisty - 18 zasad.
		</p>
<pre class="code-block">
&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</pre>
		<p>&nbsp;</p>
		<h2>Listy</h2>
		<p>
			<strong>Listy </strong>- bardzo podobne do tablic. Do poszczególnych elementów<strong> uzyskujemy dostęp poprzez podanie indeksu</strong> <strong>w nawiasie kwadratowym</strong>:
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
print(cars[2])
</pre>
		<p>
			<strong>Dostęp do końcowych elementów listy </strong>następuje poprzez podanie <strong>ujemnego</strong> <strong>indeksu</strong>, począwszy od <strong>-1</strong> wskazujący <strong>ostatni element</strong> listy, kolejno -2 to przedostatni itd.
		</p>
		<p>
			<strong>Pustą listę</strong> możemy utworzyć poprzez nadanie zmiennej pary nawiasów kwadratowych.
		</p>
<pre class="code-block">
cars=[]
</pre>
		<p>
			<strong>Dodawanie elementów na końcu listy</strong> możemy zrealizować za pomocą wbudowanej metody <code class="code-inline">append()</code>. Jak argument metoda przyjmuje wartość dodawanego elementu.
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
cars.append('toyota')
</pre>
		<p>
			<strong>Wstawianie elementów na listę</strong> wykonujemy metodą <code class="code-inline">insert()</code>. Metoda jako argument przyjmuje indeks dla nowego elementu oraz jego wartość
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
cars.insert(2, 'daewoo')
</pre>
		<p>
			<strong>Usuwanie elementów z listy</strong> możemy przeprowadzić na <strong>trzy</strong> sposoby. Po prostu usuwając element poprzez podanie nazwu listy oraz indeksu (tak jak byśmy uzyskiwali dostęp do wartości) poleceniu <code class="code-inline">del</code>.
		</p>
<pre class="code-block">
del cars[1]
</pre>
		<p>
			Kolejnym sposobem może być zabranie danej wartości z listy za pomocą metody <code class="code-inline">pop()</code>. Jako argument metoda przyjmuje indeks, tak więc możemy zabrać dowolny element, metoda <strong>domyślnie zabiera ostatni element</strong> z listy.
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
fura = cars.pop()
</pre>
		<p>
			Ostatnim, chyba najciekawszym sposobem jest metoda <code class="code-inline">remove()</code>, która wyszukuje elementu na podstawie wartości. Wyszukiwaną wartość podajemy jak argument metody.
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
swag_gablota = 'bmw'
cars.remove(swag_gablota)
</pre>
		<p>
			<strong>Uwaga!</strong> Metoda <code class="code-inline">remove()</code> usuwa tylko pierwsze wystąpienie danej wartości na liście, więc jeśli jest więcej niż jedna taka wartość to tylko pierwsza odnaleziona zostanie usunięta.
		</p>
		<p>
			Elementy na liście mogą być innej kolejności niż moglibyśmy sobie tego życzyć, w Pythonie istnieje kilka sposób na uporządkowanie listy (<em>sortowanie</em>). Pierwszą z nich jest użycie metody <code class="code-inline">sort()</code>, metoda ta wyróżnia się tym że wprowadza zmiany samej liście, czyli jej użycie w kodzie zmieni wartość listy (sortując, zmieni indeksy wartości według sortowania). Domyślnie metoda <em>sort()</em> sortuje rosnąco, jednak możemy mieć na to wpływ, podając jej argument <code class="code-inline">reverse=True</code>, teraz metoda posortuje listę malejąco. Kolejnym sposobem na sortowanie jest sposób tymczasowy, na przykład gdy kolejność danych ma znaczenie i nie możemy jej od tak sobie zmieniać, ale jednak wypadało by aby użytkownikowi wypisać posortowane dane.
			Za sortowanie tymczasowe odpowiada funkcja <code class="code-inline">sorted()</code>. Funkcja od metody tym kontekście różni się tym że musimy podać jako argument listę, a następnie zrobić coś z danymi zwróconymi albo przechować je w zmiennej albo wypisać za pomocą polecenia <code class="code-inline">print()</code>. Oczywiście funkcja <em>sorted()</em> również przyjmuje argument <em>reverse=True</em>.
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
cars.sort()
print(cars)
cars.sort(reverse=True)
print(cars)

cars = ['audi', 'bmw', 'renault', 'honda']
print(sorted(cars))
print(sorted(cars, reverse=True))
</pre>
		<p>
			W Pythonie sortowanie jest nieco bardziej skomplikowane, ponieważ ciągi tekstowe sortowane są za pomocą wartości tablicy <em>ASCII</em>. Mniejszą wartość (liczbę całkowitą przyporządkowaną do znaku w tablicy) mają wielkie litery, dlatego jeśli elementy listy mają wartość nie jednakowe (wszystkie z wielkiej/wszystkie z małej) to możemy spodziewać się że wartość zapisane wielką literą będą miały pierwszeństwo na posortowanej liście.
		</p>
		<p>
			Inną metodą na organizację listy jest jej odwrócenie, to znaczy że ostatni element będzie pierwszym, przedostatni drugim itd, do <strong>odwracania listy służy metoda <code class="code-inline">reverse()</code>.</strong>
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
cars.reverse()
</pre>
		<p>
			Warto wspomnieć że <em>reverse()</em> trwale zmienia kolejność listy.
		</p>
		<p>
			Wielkość listy możemy określić przy pomocy funkcji <code class="code-inline">len()</code>, funkcja jako argument przyjmuje naszą listę
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
len(cars)
</pre>
		<p>&nbsp;</p>
		<h2>Pętla for</h2>
		<p>
			<strong>Pętla for w Pythonie</strong> jest podobna konstrukcyjnie do pętli for z BASH-a, również używa się słowa kluczowego <code class="code-inline">in</code>. Jeśli chcielibyśmy przetłumaczyć na język potoczny pętlę <em>for</em> to będzie to mniej więcej tak: "Dla zmiennej <em>value</em> przypisz element z listy, następnie wykonaj blok kodu, na koniec przesuń się na kolejny element listy". Służy ona głównie iteracjom przez listy lub listy tworzone przez funkcję <em>range()</em>. Przy pętli <em>for</em> po raz pierwszy spotkamy się z zagnieżdżaniem bloków kodu. Przy każdej konstrukcji operującej na bloku kodu pojawia się <code class="code-inline">:</code> (dwukropek), oznaczający początek blok kodu. Wszystkie linie, które mają znaleźć się w owym bloku przesuwamy o jeden tab. Ponieważ wcięcia Pythonie są wykorzystywane do oznaczania bloku kodu, trzeba uważać przy ich stosowaniu.
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
for car in cars:
	print(car)
</pre>
		<p>
			Za generowanie serii liczb ujętych w listę odpowiedzialna jest funkcja <code class="code-inline">range()</code>. Jako argumenty przyjmuje ona zakres dla generowanej serii liczb. Cechą funkcji, o której warto wiedzieć to że ostatnia liczba z zakresu jest traktowana w sposób wyłączny, to znaczy że jeśli użyjemy funkcji <em>range()</em> do wygenerowania listy od 1 do 10, to jeśli podamy argumenty 1,10 to listę otrzymamy od 1 do 9. Ostatnia liczba jest wyłączona z przedziału. Może to wynikać z prostej implementacji funkcji <em>range()</em>, która nie uwzględnia przesunięcia indeksów tablicy o 1.
		</p>
<pre class="code-block">
for number in range(1,10):
print(number)
</pre>
		<p>
			Funkcja <em>range()</em> może przyjmować jeden argument, zakres końcowy.<br />
		</p>
<pre class="code-block">
for number in range(5):
	print(number)
</pre>
		<p>
			Dane wyjściowe takiej pętli będą od 0 od 4 - 5 elementów.
		</p>
		<p>
			Funkcję <em>range() </em>możemy wykorzystać wraz inna funkcją - <code class="code-inline">list()</code> do tworzenia list liczbowych.
		</p>
<pre class="code-block">
numbers = list(range(1,11))
for number in numbers:
	print(number)
</pre>
		<p>
			Po za określeniem zakresu funkcja <em>range()</em>przyjmuje również <em>krok</em>, czyli o ile ma zwiększyć kolejne elementy.
		</p>
<pre class="code-block">
even_numbers = list(range(2,11,2))
for evenn in even_numbers:
	print(evenn)
</pre>
		<p>
			W Pythonie mamy dostępnych kilka bardzo prostych <strong>wybudowanych funkcji statystycznych</strong>. Mianowicie:
		</p>
		<ul>
			<li><strong>min()</strong> - zwraca najmniejszą wartość na liście</li>
			<li><strong>max()</strong> - zwraca największa wartość na liście</li>
			<li><strong>sum() </strong>- zwraca sumę wszystkich elementów listy</li>
		</ul>
		<p>
			Aby ograniczyć  do minimum proces tworzenie list. Python wprowadza coś takiego co nazywa się <strong>listą składaną</strong>. Taka lista składa się z modelu wartości elementu (np. <em>value**2</em>) oraz z pętli for wraz z funkcją <em>range()</em>. Liczba stworzonych elementów znajduje się w argumencie funkcji <em>range()</em>. Elementy będą miały wartość obliczoną w modelu.
		</p>
<pre class="code-block">
squares = [value**2 for value in range(1,11)]
print(squares)
</pre>
		<p>
			Powiedzmy że do obliczeń potrzebujemy dwóch środkowych wartości z listy. Aby wydobyć je w najbardziej efektywny sposób możemy użyć <strong>wycinka listy</strong>. Wycinek tworzymy, podając w miejscu indeksu przy normalnym odwoływaniu się do listy, zakres składający z się z wartości początkowej (<strong>Uwaga! Liczonej od 0</strong>.<span style="text-decoration: underline;"></span>), dwukropka(<strong>:</strong>) oraz wartości końcowej, z tym że z wartością końcową jest identycznie co w przypadku funkcji <em>range().</em> Chcąc stworzyć wycinek z drugiego oraz trzeciego elementu, muszę policzyć od 0, czyli drugi element będzie mieć indeks 1, zakres końcowy muszę podać o 1 większy więc licząc od 0 trzeci element to 2 oraz dodaje jeszcze 1 więc koniec, końców zakres końcowy to 3.
		</p>
<pre class="code-block">
even_numbers = list(range(2,11,2))
evenn_slice = even_numbers[1:3]
</pre>
		<p>
			Zakres wartości w wycinkach, jest nieco bardziej elastyczny. Na przykład chcemy wszystkie elementy do czwartego to zamiast <em>[0:4]</em> podajemy po prostu <em>[:4]</em> <span style="text-decoration: underline;"></span><span style="text-decoration: underline;"></span><span style="text-decoration: underline;"></span><span style="text-decoration: underline;"></span>możemy pominąć wartość początkową, wtedy domyślnie będzie <em>0</em>. Podobnie jest z wartością końcową <em>[2:]</em> ten zakres oznacza że wycinek będzie zawierał wszystkie elementy od 3 do końca listy. Podobnie jak w przypadku indeksów, możemy podać ujemne wartości, co będzie oznaczało że wycinek będzie zawierać elementy z końca listy. Przy podawaniu warto pamiętać że ostatni element to -1, im większa wartość ujemna tym bliżej początku listy jesteśmy.
		</p>
<pre class="code-block">
even_numbers = list(range(2,11,2))
end_values = even_numbers[-2:]
</pre>
		<p>
			Zakres wycinku ma możliwość podania trzeciego argumentu, liczby <strong>wartości kroku przy tworzeniu wycinka</strong>.
		</p>
<pre class="code-block">
numbers = list(range(1,11))
non_even_numbers=numbers[0::2]
</pre>
		<p>
			<strong>Iterując przez wycinek</strong>, w miejscu listy podajemy nasz wycinek.
		</p>
<pre class="code-block">
numbers = list(range(1,11))
for value in numbers[0::2]:
	print(value)
</pre>
		<p>
			Często może zdarzyć się taka sytuacja, że chcemy zachować pierwotną wersję listy, ale musimy użyć jej wartości do jakiś operacji, które mogą naruszyć wartości jakiś jej elementów, w tym wypadku możemy stworzyć <strong>kopię listy</strong>.
		</p>
<pre class="code-block">
cars = ['audi', 'bmw', 'renault', 'honda']
cars_bkp = cars[:]
</pre>
		<p>
			Może zdarzyć się potrzeba posiadania listy stałych, których wartość nie może zmienić się przez cały cykl życia programu. Z taką listą jest już lepiej w niż ze zwykłymi stałymi. Taką listę nazywa się <strong>krotką</strong>. Definiowanie krotki, przypomina definiowanie listy, jednak zamiast nawiasów kwadratowych, mamy zwykłe okrągłe. Definicja wygląda w następujący sposób:
		</p>
<pre class="code-block">
rgb = ('red', 'green', 'blue')
print(rgb[0])
print(rgb[1])
print(rgb[2])
</pre>
		<p>
			Dostęp do elementów krotki, jest identyczny jak do elementów listy, co zostało zobrazowane powyżej. Teraz dla eksperymentu możemy spróbować zmienić jeden z elementów krotki.
		</p>
<pre class="code-block">
&gt;&gt;&gt; rgb = ('red', 'green', 'blue')
&gt;&gt;&gt; rgb
('red', 'green', 'blue')
&gt;&gt;&gt; rgb[0]='yellow'
&gt;&gt;&gt; Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
</pre>
		<p>
			Iteracja przebiega tak samo jak na listach. Jedyną rzeczą jaką możemy zrobić przy krotce aby zmodyfikować jej zawartość, jest jej nadpisanie.
		</p>
<pre class="code-block">
rgb = ('red', 'green', 'blue')
print(rgb[0])
print(rgb[1])
print(rgb[2])

rgb = ('cyan', 'yellow', 'magenta', 'black')
</pre>
		<p>
			Krotka zawierająca jedną wartość musi zawierać przecinek na końcu, ponieważ dzięki niemu zmienna jest rozpoznawana jako krotka.
		</p>
		<p>
			Każdy bardziej rozbudowany program będzie potrzebował instrukcji decyzyjnej. Te instrukcje uruchamiają blok kodu na podstawie testów warunkowych. Najprostszym z nich jest <strong>sprawdzenie równości</strong>.
		</p>
<pre class="code-block">
&gt;&gt;&gt; car = 'Audi'
&gt;&gt;&gt; car == 'audi'
False
</pre>
		<p>
			W powyższym przykładzie wyszedł na jaw bardzo ważny szczegół, Python jest <em>case-sensitive</em>, rozróżnia wielkość liter. Dlatego warto przed jakimkolwiek testami warunkowymi prze prowadzić normalizacje.
		</p>
<pre class="code-block">
&gt;&gt;&gt; car = 'Audi'
&gt;&gt;&gt; car.lower() == 'audi'
True
</pre>
		<p>
			Kolejnym testem jaki możemy przeprowadzić na wszystkich typach danych jest <strong>sprawdzenie nierówności</strong>.
		</p>
<pre class="code-block">
&gt;&gt;&gt;  car = 'Audi'
&gt;&gt;&gt;  car.lower() != 'audi'
False
</pre>
		<p>
			<strong>Porównania mniejsze niż, mniejsze bądź równe, większe niż, większe bądź równe</strong>, są testami wykonywanymi na liczbach. Nawet jeśli zestawimy sobie w porównaniu dwa ciągi, to Python porówna wartości z tablicy ASCII pierwszych liter i na podstawie tego zostanie zwrócona <strong>wartość boolowska</strong> <strong>True</strong> lub <strong>False</strong>.
		</p>
<pre class="code-block">
&gt;&gt;&gt; age = 19
&gt;&gt;&gt; age &gt; 21
True
&gt;&gt;&gt; age &gt;= 21
True
&gt;&gt;&gt; age &gt; 21
False
&gt;&gt;&gt; age &gt;= 21
False
car1 = 'audi'
&gt;&gt;&gt; car2 = 'bmw'
&gt;&gt;&gt; car1 &gt; car2
False
&gt;&gt;&gt; car2 &gt; car1
True
&gt;&gt;&gt; car2='Kamaz'
&gt;&gt;&gt; car1 &gt; car2
True
</pre>
		<p>
			Czasami może być tak, że takie najzwyklejsze testy jak te przeprowadzone powyżej nie wystarczą, aby instrukcja warunkowa odpaliła jakiś blok kodu potrzebne będzie sprawdzenie <strong>wyrażenia logicznego</strong> (połączonych ze sobą wiele testów), do łączenia ze sobą testów służą <strong>operatory logiczne</strong>.
		</p>
		<ul>
			<li><strong>and</strong> - operator służy do mnożenia wyników pomniejszych wyrażeń boolowskich, używany gdy wszystkie warunki muszą zwrócić tę samą wartość logiczną.</li>
			<li><strong>or</strong> - operator służy do dodawania wyników pomniejszych wyrażeń boolowskich, używany gdy ocena końcowa testu wynika z sum poszczególnych wyrażeń.</li>
			<li><strong>not</strong> - operator służy do negowania wyniku całego wyrażenia. Negowanie polega na odwróceniu wartość, kiedy mamy <em>True</em> to po zanegowaniu dostaniem <em>False</em> i vice versa.</li>
		</ul>
<pre class="code-block">
age = 19
(age &gt;= 13) and (age &gt; 20)
True
</pre>
		<p>
			Słowa kluczowego <code class="code-inline">in</code> nie wykorzystujemy tylko w pętli for, możemy również je wykorzystać do testu warunkowego, w którym to możemy określić czy dana wartość znajduje się na liście.
		</p>
<pre class="code-block">
&gt;&gt;&gt;  pojazdy = ['audi', 'bmw', 'Kamaz']
&gt;&gt;&gt; 'audi' in pojazdy
True
</pre>
		<p>
			Dodając słowo kluczowe <code class="code-inline">not</code> przed słowem <em>in</em> możemy sprawdzić czy danej wartości nie ma na liście
		</p>
<pre class="code-block">
pojazdy = ['audi', 'bmw', 'Kamaz']
'audi' not in pojazdy
False
</pre>
		<p>&nbsp;</p>
		<h2>Instrukcja if</h2>
		<p>
			Oczywiście do sterowania programu za pomocą testów warunkowych służy polecenie <strong>if</strong>, które jest częścią dużej konstrukcji warunkowej, składającej się z polecenia <em>if</em>, rozpoczynającego całą konstrukcje i definiującego pierwszy test warunkowy, jeśli test zwrócić wartość <em>True</em> zostanie wykonany blok kodu instrukcji <em>if</em>
		</p>
<pre class="code-block">
if test_warunkowy:
	#blok_kodu_instrukcji_if
</pre>
		<p>
			A co jeśli test warunkowy zwróci wartość <em>False</em>, w tym wypadku chcielibyśmy poddać wykonanie programu jeszcze jednemu warunkowi. Do tego celu służy druga część konstrukcji warunkowej. Konstrukcja <strong>if-elif</strong>, dlaczego <em>if-elif</em>, a nie samo elif. Wprowadzony tu podział ma charakter wyłącznie dydaktyczny tak naprawdę <em>if-elif-else</em> to jedno polecenie warunkowe, pozostałych dwóch części nie można użyć osobno bez polecenia <em>if</em>. Jednak możemy stosować wariacje <em>if-elif</em>, lub <em>if-else</em>.
		</p>
<pre class="code-block">
if test_warunkowy:
	#blok_kodu_instrukcji_if
elif test_warunkowy2:
	#blok_kodu_instrukcji_elif
</pre>
		<p>
			Co jeśli oba warunki zawiodą to powinniśmy zdefiniować kod blok kodu dla takiej sytuacji. Z racji tego iż można pominąć w Pythonie blok <strong>else</strong>, ja zachęcam do jego stosowania. Autor książki podaje że:
		</p>
		<blockquote>
			<p>
				Blok else jest wykorzystywany w sytuacji, gdy nie został spełniony żaden warunek z warunków wcześniej zdefiniowanych za pomocą poleceń <em>if</em> lub <em>elif</em>. Brak spełnienia warunku może wynikać z podania nieprawidłowych danych lub danych o złośliwym działaniu. Jeżeli istnieje konkretny, ostateczny warunek do sprawdzenia, rozważ użycie bloku <em>elif</em> i całkowite pominięcie bloku <em>else</em>. W ten sposób zyskasz absolutną pewność, że kod będzie wykonywany jedynie po spełnieniu oczekiwanych warunków.
			</p>
		</blockquote>
		<p>
			Moim zdaniem blok domyślny przy nie spełnieniu żadnego warunku, daje nam szanse na reakcje na nieprawidłowe dane wejściowe. Najprościej jeśli nie spełniony został żaden warunek to kończymy działanie programu.
		</p>
<pre class="code-block">
if test_warunkowy:
	#blok_kodu_instrukcji_if
elif test_warunkowy2:
	#blok_kodu_instrukcji_elif
else:
	#blok_kodu_else
</pre>
		<p>
			Przydatną rzeczą jaką możemy zrobić z poleceniem <code class="code-inline">if</code> jest <strong>sprawdzenie przed rozpoczęciem pracy z listą, czy lista aby nie jest pusta</strong>.
		</p>

<pre class="code-block">
cars=[]

if cars:
	for value in cars:
		print(value)
else:
	print("Lista jest pusta")
</pre>

		<p>
			Jak widać powyżej, aby sprawdzić czy lista jest pusta w Pythonie wystarczy podać jej nazwę w miejscu testu warunkowego.
		</p>
		<p>&nbsp;</p>
		<h2>Słowniki</h2>
		<p>
			<strong>Słowniki </strong>przypominają trochę format JSON zaimplementowany do języka programowania. Najprostszy słownik wygląda tak:
		</p>
<pre class="code-block">
miasto1 = { 'kraj': 'Polska', 'powierzchnia': 517.14, 'populacja': 1_790_658, }
</pre>
		<p>
			Nie, <strong>przecinek na końcu</strong> nie jest błędem. wskazuje tylko że do słownika mogą zostać wprowadzone nowe <strong>pary klucz-wartość</strong>. <strong>Kluczem</strong> określamy wartość występującą w słowniku, zawsze ujętą w apostrofy lub cudzysłowie, z dwukropkiem na końcu, dzięki kluczowi będziemy odwoływać się do wartości pary. Dostęp do dowolnej wartości słownika:
		</p>
<pre class="code-block">
miasto1 = { 'kraj': 'Polska', 'powierzchnia': 517.14, 'populacja': 1_790_658, }
print(miasto1['powierzchnia'])
</pre>
		<p>
			Kiedy chcemy uzyskać dostęp do konkretnej wartości to przy słowniku, klucz zapisujemy w nawiasie kwadratowym. Analogicznie do tablic asocjacyjnych w innych językach programowania.
		</p>
		<p>
			<strong>Pusty słownik</strong> definiujemy podobnie jak pustą listę tylko inne są znaki.
		</p>

<pre class="code-block">
empty_dict={}
</pre>

		<p>
			Jeśli chcemy <strong>zmodyfikować wartość</strong> z jakieś pary, to tak samo jak w przypadku list, tylko że klucz zapisujemy w miejscu indeksu.
		</p>
<pre class="code-block">
miasto1['kraj'] = 'Polska'
</pre>
		<p>
			Kiedy jakieś dane w słowniku staną nam się zbędne, możemy je usunąć przy pomocy polecenia <code class="code-inline">del</code>.
		</p>
<pre class="code-block">
del miasto1['populacja']
</pre>
		<p>
			<strong>Dodawanie nowych par klucz-wartość</strong> jest analogiczne do modyfikacji. Jeśli będzie modyfikować wartość pod kluczem, który nie istnieje w słowniku to zostanie ona dodana jako nowa para.
		</p>
		<p>
			Co jeśli podczas pracy z słownikiem odwołamy się do klucza, który nie istnieje ? Python zwróci błąd.
		</p>
<pre class="code-block">
&gt;&gt;&gt; print(miasto1['gestosc'])
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
KeyError: 'gestosc'
</pre>
		<p>
			Python daje możliwość użycia specjalnej metody <code class="code-inline">get()</code>, która jest wstanie zwrócić wartość podanego jako argument klucza, lub też zdefiniowanego jako kolejny argument komunikatu, w momencie kiedy dany klucz nie istnieje. Komunikat nie jest wymagany w przypadku jego braku nie zostanie nam nic zwrócone. Metoda <em>get()</em> nadaje się jako test czy dany klucz istnieje.
		</p>
<pre class="code-block">
if miasto1.get('gestosc'):
	#Gęstość istnieje, zrób to i to
else:
	#Gęstość nie istnieje, zrób to i to
</pre>
		<p>
			<strong>Iteracji przez słownik</strong> w sumie są trzy rodzaje: przez pary, przez klucze i przez wartości. Przez pary, będzie prawdopodobnie najpopularniejszą z wszystkich rodzajów.
		</p>
<pre class="code-block">
miasto1 = { 'kraj': 'Polska', 'powierzchnia': 517.14, 'populacja': 1_790_658, }

for key,value in miasto1.items():
	print(f"Klucz: {key}")
	print(f"Wartość: {value}\n")
</pre>
		<p>
			Metoda <strong>items()</strong> w dużym skrócie rozbije na dwie listy wszystkie klucze i wszystkie wartości, i to na nich pętla for w pamięci będzie przeprowadzać iteracje.
		</p>
		<p>
			<strong>Iteracja przez klucze</strong>, zadziała na podobnej zasadzie co przez parę jednak do iteracji wykorzysta tylko jedną listę, listę z kluczami. Analogicznie z <strong>iteracją przez wartości</strong> tylko że listę z wartościami.
		</p>
<pre class="code-block">
miasto1 = { 'kraj': 'Polska', 'powierzchnia': 517.14, 'populacja': 1_790_658, }

for key in miasto1.keys():
	print(f"Klucz: {key}\n")

for value in miasto1.values():
	print(f"Wartość: {value}\n")
</pre>
		<p>
			Z racji tego iż <code class="code-inline">keys()</code> i <code class="code-inline">values()</code> tworzą listy to działają z słowem kluczowym <code class="code-inline">in</code>.
		</p>
		<p>
			Wydania Pythona począwszy od 3.7, słownik zachowuje kolejność, w której były dodawane pary. Podczas pracy z słownikiem jego domyślną uporządkowaniem jest kolejność dodawania par.
		</p>
		<p>
			Listę kluczy możemy obudować funkcją <em>sorted()</em> aby je uporządkować.
		</p>
		<p>
			Klucze muszą być unikatowe, aby wartości się na siebie nie nakładały. Ale wśród wartości już takich wymagań nie ma. Python udostępnia funkcję <strong>set()</strong>, która<strong> na podstawie przekazanej listy</strong> <strong>tworzy zbiór z unikatowych elementów</strong>. Zbiór jest składniowo bardzo podobny do słownika, jednak zawiera sam wartości, nie zawiera on żadnych danych porządkowych.
		</p>
<pre class="code-block">
jezyki = {'python', 'ruby', 'c', 'python'}
&gt;&gt;&gt; jezyki
{'python', 'ruby', 'c'}
</pre>
		<p>
			Sposobem na to aby uzyskać dostęp do danych zapisanych na zbiorze jest iteracja lub konwersja na listę za pomocą funkcji <em>sorted()</em>. Należy pamiętać aby zapisać gdzieś listę zwróconą przez <em>sorted()</em>
		</p>
		<p>
			Przedstawienie słowników umożliwia zaprezentowanie <strong>zagnieżdżania</strong>. Pozwala ono na umieszczenie jednego złożonego typu w drugim, możemy stworzyć między innymi <strong>listę słowników</strong>, <strong>listę w słowniku</strong> czy też <strong>słownik w słowniku</strong>. Listę słowników najlepiej rozpocząć od pustej listy, następnie czy to w skutek iteracji czy danych napływających do programu tworzyć nowy słownik i załadować go do listy za pomocą metody <em>append()</em>. Trochę eksperymentując zauważyłem ciekawą rzecz, mianowicie kiedy stworzyłem sobie model słownika powyżej iteracji, i chciałem odpowiednio według testów warunkowych modyfikować wartości modelu, to na listę trafiała tylko pierwsza aktualizacja przez całą iterację. Dostęp do danych zagnieżdżonych wygląda trochę jak tablice wielowymiarowe. W zależności od tego czy jest lista słowników, to na początku podajemy indeks a później klucz, w przypadku zagnieżdżenia listy w słowniku, sytuacja jest odwrotna.
			Ostatnim przypadkiem jest słownik w słowniku, tu podajemy klucz - klucz. Do operacji na zagnieżdżeniach warto wykorzystać metody stosowane do iteracji na słownikach. Ważną rzeczą stosowaną przy zagnieżdżeniach jest ich jak największe ograniczenie, jeśli algorytm zakłada większe zagnieżdżenie niż powyżej jednego poziomu (tj. każdy klucz zawiera pojedynczą listę lub każdy element listy zawiera słownik bez zagnieżdżeń), to oznacza że ma on poważne wady konstrukcyjne i na pewno jest jakiś lepszy sposób na rozwiązanie tego problemu.
		</p>
		<p>
			Pobieranie danych od użytkowników jest realizowane dzięki funkcji <strong>input()</strong>. Funkcja ta jako argument przyjmuje, komunikat zachęcający użytkownika do wpisania danych tzw. <strong>znak zachęty</strong>. Dane wpisane przez użytkownika są zwracane w postaci ciągu tekstowego.
		</p>
		<p>
			Musimy pobrać od użytkownika, dane do obliczeń, jednak wartością zwracaną przez funkcje <em>input()</em> jest ciąg tekstowy. W tym wypadku musimy dokonać konwersji na typ całkowity. Odpowiada za to funkcja <strong>int()</strong>, której wartością zwracaną jest liczba całkowita, a argumentem dowolna wartość przypominająca liczbę, która ma zostać skonwertowana ja postać liczby całkowitej. Do obliczeń nie zawsze będziemy potrzebowali wartości całkowitej, może zdarzyć się że będziemy potrzebować wartości zmiennoprzecinkowej, aby uzyskać wartość w postaci liczby zmiennoprzecinkowej należy użyć funkcji <strong>float()</strong>. Te konwersje można odwrócić uzyskując ciąg tekstowy z liczb za pomocą funkcji <strong>str()</strong>.
		</p>
<pre  class="code-block">
&gt;&gt;&gt; age = input("Ile masz lat?")
Ile masz lat? 12
&gt;&gt;&gt; age
'12'
&gt;&gt;&gt; age = int(age)
&gt;&gt;&gt; age
12
&gt;&gt;&gt; age &gt;= 18
False
</pre>
		<p>
			Konwersje można skrócić do jednej linii, obudowując funkcję <code class="code-inline">input()</code> funkcją funkcją <code class="code-inline">int()</code>.
		</p>
<pre class="code-block">
age = int(input("Ile masz lat? "))
Ile masz lat? 18
&gt;&gt;&gt; age
18
&gt;&gt;&gt; age &gt;= 18
True
</pre>
		<p>
			Przydatną rzeczą jeśli chodzi o obliczenia liczbowe wykorzystywane w programowaniu na pewno jest <strong>operator modulo (<code class="code-inline">%</code>)</strong>. Przyjmuje dwa operandy (dzielną i dzielnik), zwraca resztę z dzielenia dzielnej przez dzielnik. Najprostszym przykładem użycia operatora modulo (<strong>%</strong>) jest sprawdzenie czy dana wartość jest parzysta czy też nie.
		</p>
<pre class="code-block">
if number % 2 == 0:
	print(f"{number} jest liczbą parzystą.")
else:
	print(f"{number} nie jest liczbą parzystą.")
</pre>
		<p>&nbsp;</p>
		<h2>Pętla while</h2>
		<p>
			Jeśli potrzebujemy pętli która działa do pewnego momentu, np. dopóki dana zmienna ma wartość taką a taką, to wtedy musimy skorzystać z pętli <strong>while</strong>. Pętla ta działa dopóty, dopóki warunek umieszczony obok słowa kluczowego <code class="code-inline">while</code> będzie zwracał wartość <em>True</em>. Pętla <em>while</em> nie posiada wbudowanego licznika, dlatego takowy licznik musimy sobie zbudować sami.
		</p>
<pre class="code-block">
number=1
while number &gt;= 10:
	if number % 2 == 0:
		print(f"{number} jest parzysta.")
    	else:
		print(f"{number} nie jest parzysta.")
    	number += 1
</pre>
		<p>
			Wynik działania powyższego przykładu:
		</p>
<pre class="code-block">
1 nie jest parzysta.
2 jest parzysta.
3 nie jest parzysta.
4 jest parzysta.
5 nie jest parzysta.
6 jest parzysta.
7 nie jest parzysta.
8 jest parzysta.
9 nie jest parzysta.
10 jest parzysta.
</pre>
		<p>
			Zmienna number przybrała w tym przykładzie rolę danych, na których operujemy oraz licznika.
		</p>
		<p>
			Czasami może zajść potrzeba aby kontrolować wykonanie programu za pomocą pętli while. Powiedzmy że mamy aplikacje, która wyświetla nam listę opcji, następnie prosi nas jej wybór, wybieramy jedną z opcji, następnie po wykonaniu czynności dedykowanych dla tych opcji wracamy do menu, gdzie znów możemy wybrać jedną z opcji lub zakończyć program. Konstrukcja takie aplikacji może opierać się na pętli <em>while</em>, której warunek zwraca wartość <em>True</em>, kiedy wybieramy opcje "Exit/Wyjście", no właśnie co się dzieje? Możliwości są trzy.
		</p>
		<ul>
			<li>Możliwość 1: Wybór konkretnej opcji przypisuje do zmiennej określoną wartość, pętla wykonuje się dopóty, dopóki wyżej wymieniona zmienna  jest nie równa wartości przypisywanej po wyborze opcji "Exit/Wyjście".</li>
			<li>Możliwość 2: Przed rozpoczęciem pętli deklarowana zmienna tzw. flaga, której przypisywana jest wartość <em>True</em>. Pętla wykonuje się do momentu gdy wartość wartość flagi jest równa <em>True</em>. Wybranie opcji "Exit/Wyjście", zmienia wartość flagi na <em>False</em>, co powoduje nie spełnienie warunku, czego następstwem jest przerwanie pracy pętli.</li>
			<li>Możliwość 3: Kod zdefiniowany pod opcją "Exit/Wyjście" zawiera tylko jedną instrukcję słowo kluczowe <strong>break</strong>. Instrukcja ta powoduje zatrzymanie wykonania bloku kodu i przejście wykonania na pierwszą instrukcję po bloku kodu pętli.</li>
		</ul>
		<p>
			Istotną rzeczą dla każdej iteracji jest możliwość jest zrestartowania iteracji, kiedy gdzieś w kodzie pętli zostanie umieszczone słowo kluczowe <strong>continue</strong>, spowoduje powrót do sprawdzenia warunku a następnie wykonania bloku pętli od początku. To polecenie przydatne może być gdy chcemy pominąć jakieś elementy
		</p>
		<p>
			Przy pracy z pętlami while warto pamiętać o prawidłowym warunku, zmianie licznika czy o zakończeniu pętli w odpowiednim momencie. Patrząc na pętle, o której mówiłem akapit wcześniej, odnośnie sterowania programem to są to pętle, które bez odpowiednich mechanizmów zatrzymujących będą wykonywać się w nieskończoność. Warunek nie zawiera licznika. Zmienna w teście warunkowym bez mechanizmów stopujących  nie zmieni swojej wartości. Chociaż i w pętlach <em>while</em> opartych na liczniki też łatwo o nieskończoną pętle. Wystarczy zapomnieć zmienić licznik na końcu bloku.
		</p>
		<p>
			Pętla <em>while</em> również nadaje się do pracy z listami czy słownikami, jedną taką ciekawą rzeczą jeśli chodzi o listy jest taki mechanizm, że jeśli umieścimy w warunku pętli nazwę listy, to  pętla będzie wykonywać się dopóki na tej liście będą jakieś elementy, mechanizmem kontroli tutaj będzie pobieranie elementów listy za pomocą metody <em>pop()</em>. Jak w każdym innym teście warunkowym w warunku pętli <em>while</em> również istnieje możliwość użycia operatora <em>in</em>
		</p>
		<p>&nbsp;</p>
		<h2>Funkcje</h2>
		<p>
			<strong>Funkcje</strong> służą do przygotowania bloku kodu , który możemy później wykorzystać wielokrotnie w części głównej programu. Funkcje ułatwiają zarządzanie kodem, testowanie oraz ewentualne debugowanie z racji tego iż jest to wydzielony fragment kodu, który możemy wykonywać niezależnie od pozostałej części programu.
		</p>
		<p>
			<strong>Definiowane funkcji </strong>rozpoczynamy od słowa kluczowego <code class="code-inline">def</code> następnie podajemy nazwę funkcji po nazwie umieszczamy <span style="text-decoration: underline;">bez spacji</span> parę nawiasów okrągłych po nawiasach oczywiście występuje dwukropek. W nowej linii od pojedynczego tabulatora rozpoczynamy blok kodu funkcji.
		</p>
		<p>
			<strong>Komentarze w funkcji</strong> umieszcza się jako tzw. <strong>docstring</strong>, którego zadaniem jest opis działania funkcji. Wszystko co zostało ujęte pomiędzy parą potrójnych cudzysłowów <strong>("""...""")</strong> jest traktowane jako <em>docstring</em>.
		</p>
<pre class="code-block">
def hello_user():
	"""To jest funkcja, która wita użytkownika"""
</pre>
		<p>
			<em>Docstring</em> wykorzystywany jest przez Python do tworzenia opisów funkcji podczas generowania dokumentacji dla poszczególnych projektów.
		</p>
		<p>
			Bardziej zaawansowane funkcje, które mają nieco więcej czynności niż wypisane "Witaj świecie!",  zazwyczaj potrzebują jakiś danych z zewnątrz. Dane, <strong>parametry funkcji</strong> deklarujemy w nawiasie zaraz obok nazwy funkcji, w ten sposób zaznaczamy że nasza funkcją będzie wymagać jakiś informacji do działania.
		</p>
<pre class="code-block">
def hello_user(username):
	"""To jest funkcja, która wita użytkownika"""
	print(f"Witaj, {username}!")
</pre>
		<p>
			Prawdziwe dane przekazujemy w momencie wywołania funkcji w części głównej. <strong>Wywołanie funkcji</strong> jest realizowane poprzez podanie jej nazwy w raz parą nawiasów okrągłych, w których w zależności od definicji umieszczamy dane niezbędne do jej wykonania. Oczywiście jeśli funkcja nie potrzebuje żadnych danych, para nawiasów pozostaje pusta.
		</p>
<pre class="code-block">
uname = 'xf0r3m'
hello_user(uname)
</pre>
		<p>
			Zmienne lub też dane umieszczone w wywołaniu funkcji nazywamy <strong>argumentami</strong>. Argumenty może przekazać do funkcji na dwa różne sposoby. Pierwszy sposób to sposób klasyczny, sposób <strong>argumentów pozycyjnych</strong>, opera się on kolejności. W jakiej kolejności parametry zostały podane w definicji funkcji, to w takiej samej kolejności należy przekazać do funkcji argumenty.
		</p>
<pre class="code-block">
def func1(para1, para2, para3):
	print(f"{para1} {para2} {para3}")

func1('Ala', 'ma', 'kota')
# Ala ma kota
</pre>
		<p>
			Python nie zwróci błędu jeśli pomylimy kolejność. Ale wynik działania funkcji może być nieoczekiwany.
		</p>
<pre class="code-block">
def func1(para1, para2, para3):
	print(f"{para1} {para2} {para3}")
	#arg1=param3, arg2=param2 arg3=param1

func1('kota', 'ma', 'Ala')
# kota ma Ala
</pre>
		<p>
			Drugą metodą jest <strong>przekazywanie argumentów w postaci słów kluczowych</strong>. Opiera się ona zasadzie par "nazwa=wartość", w tym przypadku "parametr=argument". Tutaj kolejność nie ma znaczenia. Ponieważ już podczas wywołania przypisujemy parametrowi wartość <em>argumentu</em>.
		</p>
<pre class="code-block">
def func1(para1, para2, para3):
	print(f"{para1} {para2} {para3}")

func1(para3='kota', para1='Ala', para2='ma')
# Ala ma kota
</pre>
		<p>
			Może zdarzyć się że musimy przygotować funkcję dla typowych, ciągle powtarzających się danych, które mogli byśmy podać już podczas definicji funkcji. A jeśli zajdzie taka potrzeba będziemy mogli nadpisać <strong>wartość domyślną</strong> parametrów funkcji dla innych danych.
		</p>
<pre class="code-block">
def func1(para3, para1='Ala, para2='ma'):
	print(f"{para1} {para2} {para3}"

func1('psa')
# Ala ma psa
func1('kota')
# Ala ma kota
func1('nierówno pod sufitem')
# Ala ma nierówno pod sufitem

func1('w LoL-a', 'Tola', 'gra')
# Tola gra w LoL-a
</pre>
		<p>
			Jak można zauważyć parametry w definicji funkcji zmieniły kolejność, jest wymagane przez Python, aby parametry, które będą przekazywane jako argumenty pozycyjne zawsze były na pierwszym miejscu i tak też należy przekazywać argumenty.'
		</p>
		<p>
			Funkcje często są wykorzystywane do obliczeń. Niestety co nam po obliczonych wartościach kiedy pozostają one w bloku kodu funkcji. Możemy oczywiście zwrócić wartość uzyskaną przez funkcje. Służy do tego słowo kluczowe <code class="code-inline">return</code>.
		</p>
<pre class="code-block">
def pitagoras_need_c_square(a,b):
	return (a**2 + b**2)

c_square = pitagoras_need_c_square(3,4)
print(c_square)
# 25
</pre>
		<p>
			Jak widać przy zwrocie wartości wywołanie funkcji musimy przypisać do zmiennej.
		</p>
		<p>
			Do funkcji możemy przekazać nie tylko pojedyncze dane oraz zmienne, ale również całe listy i składniowo nie rożni się to przekazania pojedynczych danych.
		</p>
<pre class="code-block">
def iteration_via_list(l):
	for list_element in l:
		print(f"{list_element}")
</pre>
		<p>
			Warto zaznaczyć że tak jak przekazujemy zmienne, to przekazujemy ich wartość. W przypadku listy prawdopodobnie zamiast wartość przekazywane jest miejsce w pamięci rozpoczęcia listy, przez to lista zdefiniowana w głównej części programu może zostać przez tą funkcję zmodyfikowana. Istnieje technika dzięki, której możemy się przed tym uchronić, możemy przekazać kopię listy (wycinek od pierwszego do ostatniego elementu).
		</p>
<pre class="code-block">
received_cars = ['audi', 'bmw', 'toyota', 'subaru'];
repaired_cars = [];

def repair_car(rcev_cars, rep_cars):

	while rcev_cars:
		repaired_car = rcev_cars.pop()
		print(f"Naprawiam: {repaired_car}")
		rep_cars.append(repaired_car)

def print_raport(rcev_cars, rep_cars):
	print("Otrzymano następujące samochody: ")
	for rcev_car in rcev_cars:
		print(f"\t - {rcev_car}")

	print("\nNaprawiono następujące samochody: ")
	for rep_car in rep_cars:
		print(f"\t - {rep_car}")

repair_car(received_cars[:], repaired_cars)
repaired_cars.reverse()
print_raport(received_cars, repaired_cars)
</pre>
		<p>
			O ile nie istnieje żaden ważny powód należy przekazywać funkcjom prawdziwą listę, użycie kopii może być mniej efektywne oraz zajmować więcej pamięci.
		</p>
		<p>
			Podczas prac z kodem możemy spotkać się z takim problemem że nie będziemy potrafili przewidzieć ile może być potrzebnych argumentów. W Pythonie możliwe jest przekazanie dla parametru dowolnej liczby argumentów. Taki parametr definiuje się z <strong>gwiazdka (<code class="code-inline">*</code>) przed nazwą. </strong>Przekazanie kilku argumentów pod ten parametr powoduje utworzenie krotki z tymi argumentami, przez które możemy normalnie iterować.
		</p>
<pre class="code-block">
def make_pizza(*toppings):
    print("Tworze pizzę: ")
    for toping in topings:
        print(f"\tDodaję: {topping}")

make_pizza('ser', 'szynka', 'pieczarki')
</pre>
		<p>
			Nic nie stoi na przeszkodzie aby użyć np. argumenty pozycyjnego wraz z <strong>krotką argumentów</strong>. Należy oczywiście pamiętać o kolejności. Python zwróci błąd ponieważ parametrem tego typu nie powinny znajdować się już żadne inne parametry.
		</p>
		<p>
			Istnieje również metoda, która umożliwi przekazanie wielu argumentów jako słów kluczowych. Podobnie do powyższego przypadku wykorzystane są <strong>gwiazdki(<code class="code-inline">**</code>) - dwie</strong> a nie jedna. Po przekazaniu par nazwa-wartość w funkcji zostanie utworzony słownik.
		</p>
<pre class="code-block">
def make_car(make, model, **car):
    car2={}
    car2['make'] = make.title()
    car2['model'] = model.title()

    for k,v in car.items():
        car2[k]=v

    return car2

car = make_car('subaru', 'outback', color='blue', towPackage=True)

print(car)
</pre>
		<p>
			Te przykład jest nieco bardziej skomplikowany. Przy korzystaniu z przekazywania wielu argumentów za pomocą słów kluczowych należy pamiętać o tym że dane w <em>słowniku</em> są ułożone według kolejności dodawania danych do słownika <span style="text-decoration: underline;">(Ta zależność pojawiła się dopiero od Pythona &gt;=3.7)</span>. W tym przypadku dane do słownika przekazane przez '<em>**car</em>' trafiają jeszcze przed przejściem do wykonywania kodu funkcji. Dlatego jeśli chcemy mieszać argumenty jak na powyższym przykładzie, należy o tym pamiętać. Poprzez utworzenie nowego słownika i na początku dodanie argumentów pozycyjnych następnie przepisanie danych ze słownika '<em>car</em>' do słownika '<em>car2</em>' danych dodanych jako wielu argumentów słów kluczowych. W ten sposób uzyskaliśmy słownik o kolejności identycznej jak argumenty podane w funkcji.
		</p>
		<p>
			W Pythonie w prostu sposób możemy utworzyć tzw. <strong>moduły</strong> w innych językach możemy nazwać je np. plikami nagłówkowymi. Tworzymy je poprzez utworzenie oddzielnego pliku i wpisanie tam wszystkich funkcji. Kiedy mamy funkcje w oddzielnym pliku pozostaje je zaimportować. Poniżej znajdują się metody importu, wraz z przykładem użycia funkcji z zaimportowanego modułu.
		</p>
<pre class="code-block">
#import sandwich
#sandwich.make_sandwich('pszenne', 'szynka', 'ser', 'ketchup')

#from sandwich import make_sandwich
#make_sandwich('pszenne', 'szynka', 'ser', 'ketchup')

#from sandwich import make_sandwich as fn
#fn('pszenne', 'szynka', 'ser', 'ketchup')

#import sandwich as mn
#mn.make_sandwich('pszenne', 'szynka', 'ser', 'ketchup')

#from sandwich import *
#make_sandwich('pszenne', 'szynka', 'ser', 'ketchup')
</pre>
			<p>
				Możemy używać słowa kluczowego <code class="code-inline">import</code> do zaimportowania całego modułu, lub zaimportować konkretną funkcję z danego modułu poprzez kombinacje słów kluczowych <code class="code-inline">from</code> oraz <em>import</em>. Gdzie po słowie <em>from</em> podajemy nazwę modułu, po słowie <em>import</em> podajemy nazwę funkcji. Ciekawą techniką jest tworzenie <strong>aliasów</strong> dla zaimportowanych modułów lub funkcji. Po nazwie modułu lub funkcji oraz po słowie kluczomym <code class="code-inline">as</code> podajemy alias czyli taką nazwę zastępczą lub pseudonim. Tworzenie aliasów przydaje się gdy np. mamy podejrzenie że funkcja w module ma taką samą nazwę jak funkcja w głównej części programu. Linia przed ostatnia z powyższego przykładu jest równoznaczna z linią pierwsza ('<em>from sandwich import *</em>' = '<em>import sandwich</em>').
			</p>
			<p>&nbsp;</p>
			<h2>Programowanie zorientowane obiektowo</h2>
			<p>
				<strong>Programowanie zorientowane obiektowo</strong> jest metodą, która pozwala programistom przedstawiać przy użyciu komputera rzeczy znane nam z realnego świata. Weźmy takiego człowieka. Człowiek jest <strong>obiektem</strong> zarówno w znanym nam świecie, jak i również może zostać przedstawiony jako obiekt w świecie wirtualnym. Jeśli człowiek staje się obiektem w ujęciu programistycznym, to jego cechy szczególne stają się <strong>właściwościami/atrybutami</strong> obiektu. Czynności jakie wykonuje mogą być <strong>metodami</strong>. Jednak człowiek jest przedstawicielem gatunku. Gatunku ludzkiego. Obiekty są również przedstawicielami gatunku jaki sobie zdefiniujemy. Tym gatunkiem są <strong>klasy</strong>.
			</p>
			<p>
				<strong>Definicje klasy</strong> rozpoczynamy od słowa kluczowego <code class="code-inline">class</code><em> </em>następnie podajemy nazwę tej klasy oraz zaraz obok nazwy <span style="text-decoration: underline;">bez spacji</span> parę nawiasów okrągłych oraz dwukropek. W następnej linii po jednym znaku tabulacji możemy rozpoczynać definicję klasy. Klasa z poziomu kodu źródłowego składa się głównie z funkcji, które tutaj nazywają się metodami. Pierwszą definiowaną metodą jest metoda <code class="code-inline">__init__</code>, <strong>przy zapisie tej nazwy należy uważać na to że jest ona obudowana dwoma znaki podkreślenia</strong> <strong>(__)</strong>. Ta metoda jest metodą specjalną, ma za zadanie zainicjować  właściwości/atrybuty zapisane w jej bloku. Te atrybuty będą atrybutami obiektu. Argumenty dla tej metody są przekazywane podczas tworzenia egzemplarza klasy, czyli obiektu.
			</p>
<pre class="code-block">
class User():
    def __init__(self,firstname,lastname,age,sex):
        self.firstname = firstname
        self.lastname = lastname
        self.age = age
        self.sex = sex
</pre>
		<p>
			Parametr <code class="code-inline">self</code>  jest obiektem, który będzie tworzony na podstawie tej klasy. Słowo kluczowe <em>self</em> będzie oznaczać po prostu obiekt tej klasy, to atrybutowi obiektu tej klasy w metodzie <em>__init__</em> nadajemy  wartość parametru 'firstname'. Z racji tego że obiekt jest egzemplarzem klasy stąd słowo self (samemu sobie).
		</p>
		<p>
			Egzemplarz klasy (obiekt) tworzymy nadając zmiennej wartości w postaci wywołania zdefiniowanej wcześniej klasy.
		</p>
<pre class="code-block">
user1 = User('Jan', 'Nowak', '47', 'M')
</pre>
		<p>
			Argumentami przekazywanymi klasie są tak naprawę argumenty dla metody <em>__init__</em>, ponieważ to ona jest uruchamiana podczas tworzenia obiektu. Argument <em>self</em> jest przekazywany automatycznie.
		</p>
		<p>
			Powiedzmy że mamy utworzy obiekt 'user1'. Dostęp do jego właściwości uzyskujemy dzięki <strong>notacji kropki (<code class="code-inline">.</code>)</strong>.
		</p>
<pre class="code-block">
print(f"Witaj {user1.firstname} {user1.lastname}")
# &gt;&gt;&gt; Witaj Jan Nowak
</pre>
		<p>
			Mamy już cechy szczególne, to teraz pora na czynności jakie ten obiekt może wykonać. Do opisu czynności obiektu wykorzystuje się metody, czyli funkcje w kontekście obiektowym. Z pierwszą metodą mieliśmy już do czynienia przy okazji metody <em>__init__</em>, może jest ona nieco przezroczysta, jednak to nadal metoda. W poniższym przykładzie stworzymy sobie metodę, która opisze nam tego użytkownika, bo na razie właściwości to suche dane.
		</p>
<pre class="code-block">
def describe_user(self):
    print(f"Imie i nazwisko: {self.firstname} {self.lastname}")
    print(f"\t-wiek: {self.age}\n\t-płeć: {self.sex}")
</pre>
		<p>
			Metoda różni się tym od funkcji że znajduje się wewnątrz klasy oraz tym że zawsze ma parametr <em>self</em>, który pozwala jej na dostęp do właściwości obiektu. Metody wywołujemy prawie przez cały czas pod czas zabawy Pythonem, więc wywołanie metody naszej klasy nie powinno być problemem.
		</p>
<pre class="code-block">
user1.describe_user()
</pre>
		<p>
			Właściwości/atrybuty obiektu nie muszą być zawsze przekazywane przez użytkownika podczas tworzenia obiektu mogą przyjmować <strong>wartości domyślne</strong> w zdefiniowane wewnątrz<em> </em>metody <em>__init__</em>.
		</p>
<pre class="code-block">
class User():
    def __init__(self, firstname, lastname, age, sex):
        self.firstname = firstname
        self.lastname = lastname
        self.age = age
        self.sex = sex
        self.rank = 'Junior user'
</pre>
		<p>
			Wraz z biegiem programu opartego na obiektach ich właściwości mogą, czasami wręcz muszą się zmienić. W Pythonie możemy to zrealizować na trzy sposoby.
		</p>
		<ul>
			<li>Sposób 1: <strong>Zmiana bezpośrednia.</strong> Po prostu bierzemy obiekt następnie za pomocą<em> notacji kropki</em> uzyskujemy dostęp do właściwości i za pomocą operatora przypisania <em>=</em> nadajemy atrybutowi nową wartość. (Ta technika generalnie nie jest polecana.)</li>
			<li>Sposób 2: <strong>Nowa metoda przeznaczona do aktualizowania wartości poszczególnych właściwości.</strong> Tworzymy metodę w parametrem self, oraz parametrem który będzie przechowywał nową wartość metody, w bloku w metody do atrybutu uzyskujemy dostęp poprzez parametr <em>self</em> oraz notację kropki i nadajemy mu wartość parametru, która ma zostać przekazana w postaci argumentu z głównej części programu.</li>
			<li>Sposób 3: <strong>Nowa metoda inkrementująca lub dekrementując wartość właściwość. </strong>Ta metoda od tej ze sposobu nr. 2 różni się w zasadzie tylko znakiem w tym wypadku jest <em>+=</em> a nie <em>=</em>. Wartość o jaką będziemy zmieniać naszą właściwość również podajemy w postaci parametru. Oczywiście może to zależeć od metody.</li>
		</ul>
		<p>
			<span style="text-decoration: underline;">Sposób 1:</span>
		</p>
<pre class="code-block">
user1.rank = 'Standard user'
</pre>
		<p>
			<span style="text-decoration: underline;">Sposób 2:</span>
		</p>
<pre class="code-block">
class User():
    def __init__(self, firstname, lastname, age, sex):
        self.firstname = firstname
        self.lastname = lastname
        self.age = age
        self.sex = sex
        self.rank = 'Junior user'

    def promote_user(self, new_rank):
        self.rank = new_rank

user1 = User('Jan', 'Nowak', '47', 'M')
user1.promote_user('Standard user')
</pre>
		<p>
			<span style="text-decoration: underline;">Sposób 3:</span>
		</p>
<pre class="code-block">
class User():
    def __init__(self, firstname, lastname, age, sex):
        self.firstname = firstname
        self.lastname = lastname
        self.age = age
        self.sex = sex
        self.rank = 'Junior user'

    def promote_user(self, new_rank):
        self.rank = new_rank

    def happy_birthday(self):
        print(f"Happy Birthday {self.firstname.title()}")
        self.age += 1

user1 = User('Jan', 'Nowak', '47', 'M')
user1.promote_user('Standard user')
user1.happy_birthday()
</pre>
	<p>
		Mamy sobie naszych użytkowników. Jednak potrzebujemy specjalnego użytkownika, który będzie tym wszystkim zarządzał - Administratora. Problem napotykamy wtedy kiedy chcemy zdefiniować jakieś ekstra metody dla admina, ale nie chcemy umieszczać ich w tej samej klasie do definiowania użytkowników, musimy również pamiętać że admin to też użytkownik, i wypadało by mieć w bazie jego dane. Przekopiowanie kodu jest nieefektywne, ale z pomocą przechodzi na <strong>dziedziczenie</strong>, czyli tworzenie <strong>klas potomnych</strong> na podstawie istniejącej już klasy.
	</p>
	<p>
		Przy tworzeniu klas potomnych warto pamiętać o jednej rzeczy. Klasa potomna jest to oddzielna klasa zawierająca połączenie z <strong>klasą nadrzędną</strong>. Klasy potomne mogą inicjować dla swoich obiektów właściwość klasy nadrzędnej oraz obiekty klas potomnych mogą korzystać z metod klasy nadrzędnej. Definicja takiej klasy wygląda następująco.
	</p>
<pre class="code-block">
class User():
    def __init__(self, firstname, lastname, age, sex):
        self.firstname = firstname
        self.lastname = lastname
        self.age = age
        self.sex = sex
        self.rank = 'Junior user'
        self.quota = 100_000_000

    def promote_user(self, new_rank):
        self.rank = new_rank

    def happy_birthday(self):
        print(f"Happy Birthday {self.firstname.title()}")
        self.age += 1

    def check_quota_type(self):
        if self.quota &lt; 0:
            print('Unlimited')
        else:
            print('100MB')

class Admin(User):
    def __init__(self, firstname, lastname, age, sex):
        super().__init__(firstname, lastname, age, sex)
        self.quota = -1
        self.rank = 'Admin'

    def ban_user(self, username):
        print(f'Użytkownik {username} został zbanowany')
</pre>
		<p>
			Cechami po których można poznać że dana klasa jest klasą potomną, jest to że <strong>w parametrach klasy znajduje się nazwa klasy nadrzędnej.</strong> W metodzie __init__ występuje metoda <code class="code-inline">super()</code>, której celem jest realizowanie połączenia pomiędzy klasą potomną a klasą nadrzędną. Użycie metody <em>super()</em> zależy od konstrukcji klasy nadrzędnej.  Utworzenie takiego obiektu różni się tylko nazwą klasy.
		</p>
<pre class="code-block">
root = Admin('Jan' 'Kowalski', 25, 'M')
root.happy_birthday()
# Happy Birthday Jan
root.check_quota_type()
# Unlimited
</pre>
		<p>
			Atrybuty mogą przechowywać wiele rzeczy, od pojedynczych wartość po obiekty innych klas. Istnieje możliwość wewnątrz klasy <strong>przekazać atrybutowi jako wartość egzemplarz obiektu. </strong>Rozważmy to że musimy każdemu z naszych użytkowników zdefiniować uprawnienia, co im wolno, a co nie. Możemy spojrzeć na zestaw uprawnień jak na obiekt.
		</p>
<pre class="code-block">
class User():
    def __init__(self, firstname, lastname, age, sex):
        self.firstname = firstname
        self.lastname = lastname
        self.age = age
        self.sex = sex
        self.rank = 'Junior user'
        self.quota = 100_000_000
        self.permissions = Permissions('User')

    def promote_user(self, new_rank):
        self.rank = new_rank

    def happy_birthday(self):
        print(f"Happy Birthday {self.firstname.title()}")
        self.age += 1

    def check_quota_type(self):
        if self.quota &gt; 0:
            print('Unlimited')
        else:
            print('100MB')

class Permissions():
    def __init__(self, user_type):
        if user_type == 'Administrator':
           self.permissions = ['może dodać post',
               'może usunac post',
               'może zbanować użytkownika']
        else:
           self.permissions = ['może dodać post', 'może usunać post']

    def show_permissions(self):
        for permission in self.permissions:
            print(f"- {permission}")


class Admin(User):
    def __init__(self, firstname, lastname, age, sex):
        super().__init__(firstname, lastname, age, sex)
        self.quota = -1
        self.rank = 'Admin'
        self.permissions = Permissions('Administrator')

    def ban_user(self, username):
        print(f'Użytkownik {username} został zbanowany')

root = Admin('Jacek', 'xf0r3m', 25, 'M')
root.permissions.show_permissions()
print('\n')
user1 = User('Jan', 'Nowak', 47, 'M')
user1.permissions.show_permissions()
</pre>
		<p>
			W powyższym przykładzie pokazano jak można użyć obiektu jako wartości atrybutu innego obiektu oraz jak uzyskać dostęp do metod takiego obiektu. 'root' jest obiektem w klasie 'Admin', następnie po kropce podajemy nazwę atrybutu w tym przypadku jest 'permissions', aby po następnej kropce (z racji tego że wartość 'permissions' to też obiekt) podajemy nazwę metody 'show_permissions()' i w ten sposób uzyskaliśmy dostęp do zdefiniowanych w innym obiekcie uprawnień przypisanych do obiektów użytkowników jako atrybuty.
		</p>
		<p>
			<strong>Klasy podobnie jak funkcje też można umieszczać w modułach</strong>, klasy umieszcza się w modułach w identyczny sposób jak funkcje. Identycznie też się je importuje. Kilka akapitów wyżej jest opis jak to zrobić.
		</p>
		<p>
			Wiele modułów zwierających pomocne klasy oraz funkcje jest dostarczanych wraz z Python jako <strong>Biblioteka standardowa Pythona.</strong> Wśród nich możemy znaleźć taki moduł jak <code class="code-inline">random</code >, który zawiera funkcje służące do generowania liczb losowych - <strong>randint() </strong><em>(lepiej nie używać jej w dużych projektach ze względów bezpieczeństwa)</em> oraz np. <code class="code-inline">choice()</code>, która zwraca nam losowo wybraną wartość z listy lub krotki.
		</p>
<pre class="code-block">
&gt;&gt;&gt; from random import choice
&gt;&gt;&gt; cars = ['Shelby Cobra', 'Chevy', 'Pontiac', 'Dodge', 'Mustang']
&gt;&gt;&gt; today_car = choice(cars)
&gt;&gt;&gt; today_car
'Dodge'
</pre>
		<p>&nbsp;</p>
		<h2>Obsługa plików</h2>
		<p>
			Python tak wiele języków programowania umożliwia pracę z plikami. Dostęp do pliku uzyskujemy w dość dziwny, ale bezpieczny (dla pliku) oraz efektywny sposób.
		</p>
<pre class="code-block">
with open('filename.txt') as file_object
</pre>
		<p>
			Samemu otwarciu pliku służy funkcja <code class="code-inline">open()</code>, jednak jeśli skorzystalibyśmy z niej bez tej specyficznej obudowy, po zakończeniu wykonywania na nim jakiś operacji, musielibyśmy go zamknąć. Tylko pytanie, kiedy? Po ostatniej czynności na nim wykonanej? Nie wiadomo. Dlatego też w Pythonie pliki otwiera się za pomocą słowa kluczowego <code class="code-inline">with</code>, które to zamyka plik kiedy przestaje być potrzebny, czy to naszemu programowi, czy to Pythonowi do jego interpretacji. Sekcja <code class="code-inline">as file_object</code>, będzie nam przedstawiać odniesie do pliku jako obiekt '<em>file_object</em>'. Wielu przypadkach możemy spotkać się ze skróceniem '<em>file_object</em>' do <strong>f</strong>. Czynności wykonywane na pliku są umieszczane w bloku kodu pod linią otwarcia pliku z użyciem słowa kluczowego <em>with</em>.
		</p>
		<p>
			W powyższym przykładzie, wewnątrz funkcji <em>open()</em> znajduje się argument o nazwie 'filename.txt', jest to ścieżka dostępowa do pliku, która może być względna - odnosić się od danego miejsca, lub też bezwzględna - pełna ścieżka od najwyższego katalogu na systemie plików w Unix-ach (root[/]), w Windows (Katalog dysku np. c:\ itp.). 'Filename.txt' jest ścieżką względną ponieważ odnosi się od CWD (obecnego katalogu roboczego - katalogu, w którym się znajdujemy, mamy otwarte IDE lub w katalogu lub w którym wykonuje się skrypt Pythona). W Windows stosujemy te same slash-e (/) co w Unix-ach, lub jeśli się już upieramy przy Windowsowych backslash-ach (\), to musimy podać je podwójnie, ponieważ backslash w Python oznacza rozpoczęcie białego znaku.
		</p>
		<p>
			Dane z plików możemy odczytać na trzy różne sposoby.
		</p>
		<ul>
			<li>Sposób 1 - <strong>Ściągnięcie całej zawartości pliku jako ciągu tekstowego do zmiennej</strong>. </li>
			<li>Sposób 2 - <strong>Iteracja przez odniesienie do pliku</strong>.</li>
			<li>Sposób 3 - <strong>Przechowanie pliku jako lista wierszy występujących w pliku</strong>.</li>
		</ul>
		<p>
			<span style="text-decoration: underline;">Sposób 1:</span>
		</p>
<pre class="code-block">
with open('filename.txt') as f:
    plik = f.read()
</pre>
		<p>
			Warto zwrócić uwagę na dodatkowy ostatni pusty wiersz. Metoda <code class="code-inline">read()</code> po napotkaniu końca pliku zwraca pusty wiesz. Z racji tego że pusty wiersz (znak przejścia do nowej linii '<em>\n</em>'), to biały znak, cały plik ściągnęliśmy do zmiennej w postaci pojedynczego ciągu tekstowego, to oznacza to że znak znajduje się po prawej stronie ciągu, więc za pomocą metody operującej na ciągach tekstowych <em>rstrip()</em> możemy usunąć ten pusty wiersz.
		</p>
		<p>
			<span style="text-decoration: underline;">Sposób 2:</span>
		</p>
<pre class="code-block">
with open('filename.txt') as f:
    for line in f:
        print(f"{line.replace('Python', 'C')}")
</pre>
		<p>
			Metoda <strong>replace()</strong> zamienia wszystkie wystąpienia w ciągu pierwszego argumentu na drugi argument.
		</p>
		<p>
			<span style="text-decoration: underline;">Sposób 3:</span>
		</p>
<pre class="code-block">
with open('filename.txt') as f:
    plik = f.readlines()

for linia in plik:
    print(f"{linia.replace('Python', 'C')}")
</pre>
		<p>
			Metoda <code class="code-inline">readlines()</code> zwraca nam listę wierszy pliku, którą przechowujemy w zmiennej plik.
		</p>
		<p>
			Funkcja <em>open()</em> pozwala na wybranie atrybutu dla otwieranego pliku.
		</p>
		<ul>
			<li><strong>'r'</strong> - Atrybut domyślny, otwiera tylko plik do odczytu.</li>
			<li><strong>'w'</strong> - Otwiera plik do zapisu. Jeśli nie może znaleźć pliku, nie generuje błędu. Tworzy nowy plik pod podaną funkcji ścieżką. Jeśli plik o takiej nazwie już istnieje to zostaje nadpisany.</li>
			<li><strong>'a'</strong> - Otwiera plik do dopisywania. Dopisuje dane do pliku. Nie nadpisuje danych w pliku. Podobnie jak atrybut <em>'w'</em> w przypadku braku pliku na ścieżce, to zostanie o utworzony.</li>
			<li><strong>'r+'</strong> - Rozszerza otwarcie pliku do odczytu o możliwości dopisania danych. </li>
		</ul>
		<p>
			Zapis danych w pliku polega na otwarciu pliku do zapisu lub dopisywania używając wyżej wymienionych atrybutów, jako drugiego argumenty funkcji <em>open()</em>. Plik nie musi istnieć na podanej ścieżce, zostanie utworzony w momencie zamknięcia odniesienia prze słowo kluczowe <em>with</em>
		</p>
<pre class="code-block">
with open('filename.txt', 'w') as f:
    f.write('xf0r3m')

with open('filename.txt') as f:
    plik = f.read()

print(f"{plik}")
# xf0r3m
</pre>
		<p>&nbsp;</p>
		<h2>Obsługa błędów</h2>
		<p>
			Python posiada konstrukcję do obsługi błędów, to znaczy że jeżeli w pewnym bloku umieścimy kod (technicznie, umieszcza się tam tylko jedną linię do której nie możemy być pewni że uruchomienie jej nie spowodują błędu), to jeśli spowoduje on błąd określony w drugiej części konstrukcji, zostanie wykonany kod z bloku tej drugiej części. Tą konstrukcją jest <code class="code-inline">try-except</code>. Najbardziej koronnym przykładem jest chyba dzielenie przez zero.
		</p>
<pre class="code-block">
try:
    print(8 / 0)
except ZeroDivisionError:
    print("Nie wolno dzielić przez 0")
</pre>
		<p>
			Jeśli kod w bloku <em>try</em> wykona się bez błędu, to zostanie wyświetlony wynik z dzielenia. Jednak nigdy nie się to nie stanie. Ponieważ wykonanie linii <code class="code-inline">print(8/0)</code> spowoduje wygenerowanie błędu <strong>division by zero</strong>. Błędy w programowaniu możemy nazwać wyjątkami od wykonania. Każdy błąd jest częścią <strong>obiektu wyjątku</strong> w tym przypadku obiektem wyjątku dla błędu jest <code class="code-inline">ZeroDivisionError</code>. Skąd to wiadomo ? Otóż z błędów zwróconych przez sam Python jako <strong>stos wywołań.</strong> Ostatnia linia komunikatu o błędzie. Mówi nam: '<em>obiekt wyjątku:</em> <em>błąd</em>'.  Aby obsłużyć błąd, w linii <em>except</em> podajemy <em>obiekt wyjątku</em>, następnie w jej bloku definiujemy kod który ma się wykonać kiedy Python napotka błąd tego typu. Jeśli potrzebujemy obiektu wyjątku, to spróbujmy zmusić tę niepewną linię do wygenerowania błędu bez jego obsługi. Python poda nam nazwę obiektu wyjątku.
		</p>
		<p>
			W skład tej konstrukcji wchodzi jeszcze <code class="code-inline">else</code>, w tym bloku definiowany jest kod który jest wykonywany, kiedy kod w bloku <em>try</em> nie spowoduje błędu.
		</p>
<pre class="code-block">
a = input("Podaj pierwszą liczbę: ")
b = input("Podaj drugą liczbę: ")

try:
    result = int(a) + int(b)
except ValueError:
    print("Jedna z podanych wartości jest tekstem nie liczbą!")
else:
    print(f"{result}")
</pre>
		<p>
			Często będzie tak, że nie będziemy chcieli wykonywać żadnego kodu, ani informować nikogo o tym że wystąpił wyjątek. Wtedy możemy skorzystać ze słowa kluczowego <strong>pass</strong>, które celem jest rezerwacja miejsca w bloku, na potrzeby późniejsze rozbudowy. Użycie instrukcji <em>pass</em> możemy tłumaczyć jako "do nothing". Z racji tego że instrukcja <em>pass</em> pozwala na ciche przyzwolenie na błędy. Musimy zdecydować kiedy użytkownik naszego programu powinien być informowany o błędzie. Na pewno wtedy gdy wyjątek powoduje jakaś informacja, która pochodzi od niego samego.
		</p>
		<p>
			Z racji tego iż mamy omówione pliki oraz wyjątki, czyli możemy definiować kod, który obsłuży sytuacje, gdy próbujemy odczytać plik który nie istnieje. Możemy zapisywać dane z naszych programów do pliku, a przy następnym uruchomieniu je wczytywać. Do tego celu wykorzystamy moduł <code class="code-inline">json</code>, który umożliwia użycie formatu JSON (JavaScript Object Notation) do przechowywania danych. A w szczególności dwie funkcje,<code class="code-inline">dump()</code>oraz <code class="code-inline">load()</code>.
		</p>
		<p>
			Funkcja <em>dump()</em> jak argumenty pobiera, dane (jako pierwszy argument pozycyjny) np. zmienną, równie dobrze może być to lista. Drugim argumentem jest odniesie do pliku.
		</p>
<pre class="code-block">
import json

username = 'xf0r3m'

with open('filename.json', 'w') as f:
    json.dump(username,f)
</pre>
		<p>
			Dane zostaną za pisane w pliku. Nie koniecznie w formacie JSON jaki znamy z JavaScript. Idealnie funkcja <em>dump()</em> na JSON przerabia słowniki, którym chyba najbliżej do tego formatu. Odczyt danych z takiego pliku jest wykonywany jest za pomocą funkcji <em>load()</em>.
		</p>
<pre class="code-block">
import json

with open('filename.json', 'w') as f:
    username = json.load(f)

print(f"{username})
# xf0r3m
</pre>
		<p>&nbsp;</p>
		<h2>Testy jednostkowe</h2>
		<p>
			Python za pomocą modułów biblioteki standardowej umożliwia nam przeprowadzenie testów jednostkowych dla stworzonych przez nas funkcji oraz klas. Jeśli chcemy być naprawdę dobrzy w programowanie, i to nie zależnie od języka powinniśmy testować nasz kod. Nie mówię o tworzeniu testów jednostkowych dla <em>hello world</em>, ale kiedy nasz projekt dość pokaźnie urósł. Zawiera klasy lub/i funkcję, to powinien on zawierać testy tych konstrukcji. Na czym polega test jednostkowy ? Najprościej rzecz biorąc na sprawdzeniu czy wartość zwracana przez funkcje lub atrybut modyfikowany przez metodę jest równy z predefiniowaną przez nas wartością, którą uznajemy za poprawną. Takie porównanie nazywamy asercją. Zakładamy że wartość użyta do asercji jest równa zdefiniowanej wartości.
			Jeśli tak jest to zostaje zaliczony, w przeciwnym wypadku wykonanie zostaje przerwane (w przypadku asercji jako funkcji). Asercja w Pythonie nie organiczna się tylko do sprawdzenia równości. Poniżej znajduje się tabelka z możliwymi funkcjami asercji zaimplementowanymi w module <strong>unittest</strong>. To ten moduł odpowiada za testy jednostkowe.
		</p>
		<figure>
			<table>
				<tbody>
					<tr>
						<td><strong>Metoda</strong></td>
						<td><strong>Opis</strong></td>
					</tr>
					<tr>
						<td><em>assertEqual(a, b)</em></td>
						<td>Sprawdza czy <em>a == b</em></td>
					</tr>
					<tr>
						<td><em>assertNotEqual(a, b)</em></td>
						<td>Sprawdza czy <em>a != b</em></td>
					</tr>
					<tr>
						<td><em>assertTrue(x)</em></td>
						<td>Sprawdza czy <em>x</em> przyjmuje wartość <em>True</em></td>
					</tr>
					<tr>
						<td><em>assertFalse(x)</em></td>
						<td>Sprawdza czy <em>x</em> przyjmuje wartość False</td>
					</tr>
					<tr>
						<td><em>assertIn(element, lista)</em></td>
						<td>Sprawdza czy <em>element</em> jest na <em>liście</em></td>
					</tr>
					<tr>
						<td><em>asserNotIn(element, lista)</em></td>
						<td>Sprawdza czy <em>element</em> nie znajduje się na <em>liście</em></td>
					</tr>
				</tbody>
			</table>
			<figcaption>Metody asercji oferowane przez moduł unittest</figcaption>
		</figure>
		<p>
			Na potrzeby przedstawienia testów zaczniemy od zdefiniowania sobie w module (<em>city_functions.py</em>) prostej funkcji '<em>city_countries</em>', która pobiera od użytkownika nazwę miast oraz nazwę kraju, w którym to miasto leży następnie zwraca ciąg np. dla danych Warszawa Polska: Warszawa, Polska.
		</p>
<pre class="code-block">
def city_country(city, country):
  cc = f"{city.title()}, {country.title()}"
  return cc
</pre>
		<p>
			Aby wywołać taką funkcje, z racji tego że jest plik modułu w nowym pliku musimy zaimportować moduł i wywołać funkcję:
		</p>
<pre class="code-block">
from city_functions import city_country
city_country('Warszawa', 'Polska')
# Warszawa, Polska
</pre>
		<p>
			Powiedzmy z racji tego że jest funkcja dużego projektu, musimy stworzyć dla niej test jednostkowy. Testy definiuje się w klasie potomnej klasy TestCase modułu unittest. Jedna metoda w wewnątrz klasy = jeden test. Taka klasa staje się zbiorem testów. Kiedy dla każdej funkcji w naszym projekcie zdefiniujemy chociaż jeden test, to możemy mówić wówczas o <strong>całkowitym pokryciu zbioru testów</strong>. Zatem dla testów jednostkowych utworzymy nowy plik, nazwiemy go <em>test_cities.p</em>y
		</p>
<pre class="code-block">
import unittest
from city_functions import city_country

class TestCitiesFunctions(unittest.TestCase):

    def test_city_country(self):
        cc = city_country('Warszawa', 'Polska')
        self.assertEqual(cc, 'Warszawa, Polska')

unittest.main()
</pre>
		<p>
			importujemy moduł <code class="code-inline">unittest</code>, następnie importujemy naszą funkcję. Tworzymy klasę potomną klasy <code class="code-inline">unittest.TestCase</code>, w tym przypadku o nazwie <code class="code-inline">TestCitiesFunctions</code>. Wewnątrz niej jako metodę definiujemy test. Funkcja <code class="code-inline">main()</code> modułu <em>unittest</em> <strong>uruchomi automatycznie każdą metodę w zbiorze, których nazwy zaczynają się od ciągu <em>test_</em></strong>, zatem nie potrzeba jej wywoływać. Wewnątrz metody wywołujemy naszą funkcję zachowując jej wartość zwracaną w zmiennej <code class="code-inline">cc</code> następnie w jednej z metod asercji w tym przypadku
			<code class="code-inline">assertEqual</code> podstawiamy otrzymaną wartość następnie wartość, którą naszym zdaniem powinniśmy otrzymać od funkcji dla podanych w wywołaniu argumentów. Na końcu uruchamiamy zbiór testów.  Wynik testu znajduje się poniżej.
		</p>
<pre class="code-block">
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</pre>

		<p>
			W prawdzie nie wiele informacji, choć nas powinna zaciekawić pierwsza linijka, zwracany jest w niej rezultat testu, jeśli widzimy kropkę (<code class="code-inline">.</code>), oznacza to że test zakończył się sukcesem. Innymi wartościami zwrotnymi jest wielka litera <strong>F</strong>, oznaczająca nie powodzenie asercji, otrzymaliśmy inny wynik niż zakładaliśmy, oraz wielka litera <strong>E</strong>, oznaczająca błąd gdzieś w kodzie. Np. jeśli rozbudowujemy funkcje o kolejne parametry, ale już zapomnimy w teście tych parametrach.
		</p>
		<p>
			Rozbudujemy naszą funkcję o kolejny parametr pozwalający przedstawić populacje.
		</p>
<pre class="code-block">
def city_country(city, country, population):
    cc = f"{city.title()}, {country.title()} - populacja {population}"
    return cc
</pre>
		<p>
			Próbując wykonać test dla tej funkcji dostaniemy o taką odpowiedź:
		</p>
<pre class="code-block">
E
======================================================================
ERROR: test_city_country (__main__.TestCitiesFunctions)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/xf0r3m/python/test_cities.py", line 8, in test_city_country
    cc = city_country('Warszawa', 'Polska')
TypeError: city_country() missing 1 required positional argument: 'population'

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
</pre>
		<p>
			Błąd polega na tym że zapomnieliśmy jednym argumencie, jeśli zmienimy ten argument na opcjonalny, wtedy test zostanie pomyślnie wykonany. Poniżej zamieszczam również dane zwracane, kiedy wartość rzeczywista różni się od przez nas założonej, pojawia się wtedy błąd asercji.
		</p>
<pre class="code-block">
F
======================================================================
FAIL: test_city_country (__main__.TestCitiesFunctions)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/xf0r3m/python/test_cities.py", line 9, in test_city_country
    self.assertEqual(cc, 'Warszawa, Polska')
AssertionError: 'Warszawa, Polska - populacja ' != 'Warszawa, Polska'
- Warszawa, Polska - populacja
+ Warszawa, Polska


----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
</pre>
		<p>
			Oczywiście kiedy zdefiniujemy kolejne testy, to będą pojawiać się kolejne w linijce kropki lub litery E czy F,  wszystko w zależności od wyniku testu.
		</p>
		<p>
			Testy jednostkowe możemy tworzyć nie tylko dla funkcji ale i dla klas (bardziej metod). Przygotowałem poniżej klasę modelującą pracownika w swoich atrybutach zawiera imię, nazwisko oraz roczne zarobki. W klasie znajduje się również metoda odpowiedzialna za przyznawanie podwyżki, domyślną wartością podwyżki jest 5000. Naszym zadaniem jest stworzenie dwóch testów sprawdzających ową metodę. Jak w przykładzie z funkcją, klasę umieszczamy w odrębnym pliku modułu.
		</p>
		<p>
			<span style="text-decoration: underline;">Plik: pracownik.py</span>
		</p>
<pre class="code-block">
class Employee():

    def __init__(self, imie, nazwisko, y_salary):
        self.imie = imie
        self.nazwisko = nazwisko
        self.y_salary = y_salary

    def give_raise(self, amount_raise=5000):
        self.y_salary += amount_raise
</pre>
		<p>
			Poniżej znajduje się plik ze zbiorem testów. Dla klas tworzymy go w identyczny sposób jak dla funkcji, z jedną różnicą. Dla poprawności testu, każdy test powinien otrzymać oddzielny egzemplarz klasy, aby nie powtarzać kodu tworzenia egzemplarza, z pomocą przychodzi nam metoda <em>unittest</em> o nazwie <code class="code-inline">setUp</code>. Kiedy <span style="text-decoration: underline;">definiujemy</span> taką metodę w wewnątrz zbioru testów, powinna zwierać kod przeznaczony do utworzenia egzemplarza danej klasy. Ta metoda będzie wywoływana przez Python przed każdym wywołaniem testu.
		</p>
		<p>
			<span style="text-decoration: underline;">Plik: test_employee.py</span>
		</p>
<pre class="code-block">
import unittest
from pracownik import Employee

class EmployeeTest(unittest.TestCase):

    def setUp(self):

        imie = 'Jan'
        nazwisko = 'Nowak'
        y_salary = 140_000

        self.new_employee = Employee(imie, nazwisko, y_salary)

    def test_give_default_raise(self):

        self.new_employee.give_raise()
        self.assertEqual(self.new_employee.y_salary, 145_000)

    def test_give_custom_raise(self):
        self.new_employee.give_raise(25_000)
        self.assertEqual(self.new_employee.y_salary, 165_000)

unittest.main()
</pre>
		<p>
			Naszymi testami było sprawdzenie metody odpowiedzialnej za przyznawanie podwyżek. Pierwszy test to podwyżka o wartość domyślnej a drugi to podwyżka zdefiniowana przez użytkownika. Danymi zwracanymi przez Python dla uruchomienia tych testów są:
		</p>
<pre class="code-block">
..
----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK
</pre>
		<p>&nbsp;</p>
		<h2>Koncepcje stylu kodu źródłowego</h2>
		<p>
			Poniżej przedstawiam koncepcje stylu nadawanego zapisom kodu źródłowego, ponieważ "<em>Now is better than never" </em>oraz <em>"Beautiful is better than ugly"</em>.
		</p>
		<p>
			Kilka reguł do których należy stosować pod czas używania zmiennych w Pythonie.
		</p>
		<ul>
			<li>W nazwach zmiennych mogą znajdować się jedynie, cyfry i znaki podkreślenia. Nazwa może rozpoczynać się od litery lub znaku podkreślenia ale nie od cyfry.</li>
			<li>Niedozwolone jest stosowanie spacji w nazwach zmiennych, choć znak podkreślenia można stosować w charakterze separatora. </li>
			<li>Należy unikać używania w nazwach zmiennych słów kluczowych Pythona oraz nazw funkcji.</li>
			<li>Nazwa zmiennej powinna być krótka, choć jednocześnie czytelna.</li>
			<li>Ostrożnie należy używać małej litery <em>l</em> oraz wielkiej litery <em>O</em>. Mogą zostać mylnie odczytane jako 1 lub 0.</li>
		</ul>
		<p>
			Zmienne w Pythonie zapisujemy z małych liter.
		</p>
		<p>
			Odnośnie komentarzy, to warto sobie opisywać jakieś bardziej złożone fragmenty naszego programu, żeby później, kiedy powrócimy do kodu po jakimś czasie, nie tracić czasu na próbę zrozumienia co autor miał na myśli.
		</p>
		<p>
			Generalnie konwencje stylu, będą stosowane nie po to aby kod był łatwy do zapisu, ale do odczytu właśnie. Jest dokument w sieci nazywa się PEP 8 (<em>Python Enhancement Proposal)</em>, który opisuje sposoby nakładania stylu na tworzony kod. Pierwszą rzeczą którą jest podczas zapisu kodu łatwego do odczytu, są <strong>wcięcia</strong>. W Pythonie sprawa jest nieco paradoksalna, ponieważ nie możemy sobie szastać wcięciami na prawo i lewo, ponieważ wcięcia często oznaczają blok kodu, ale jednocześnie przez to Python sam nakazuje nam stosowanie wcięć przy definiowaniu bloku kodu. Specyfikacja PEP 8 zaleca użycia czterech spacji jako jednego poziomu wcięcia. Najnowsze wersje edytorów ustawiają jeden znak tabulacji na wielkość czterech spacji. Kolejną rzeczą jest <strong>długość wiersza</strong>, nie powinniśmy przekraczać 80 znaków, takie zalecenie później ułatwi nam pracę kiedy na jednym ekranie będziemy musieli mieć podzielone okno edytora na kilka plików naraz.
			W oknie edytora możemy zobaczyć taką pionową kreskę, właśnie ona stoi na miejscu 80 znaku. Taka linia powinna być już włączona, jeśli nie jest to zawsze można ją włączyć. Do organizacji kodu w schludny plik tekstowy mogą pomóc nam <strong>puste wiersze</strong>. Nie należy ich jednak nadużywać. Metodę jaką ja stosuje jest rozdzielanie kodu ze względu na jego kontekst. Np. mam sobie wywołanie funkcji, która zwraca mi wartość do zmiennej - jest jedna linia. Teraz chcę to wypisać - to jest druga linia operująca na tych samych danych, czyli umieszczam ją jedną pod drugą. Kiedy muszę wywołać podobnie inną funkcję muszę robię linię odstępu przed kolejnymi instrukcjami.
		</p>
		<p>
			PEP 8 opisuje również styl dla testów warunkowych. W tego zalecenia powinniśmy rozdzielać operandy od operatora spacją, zarówno w test prostych jak i złożonych.
		</p>
		<p>
			Podczas nadawania stylu funkcjom powinniśmy pamiętać o kilku kwestiach. Nazwa funkcji powinna sugerować jej przeznaczenie i składać się z małych liter i znaków podkreślenia. W kodzie każdej funkcji powinien znajdować się komentarz zaraz na początku bloku kodu funkcji, dla komentarza należy użyć formatu <strong>docstring</strong>. W przypadku definiowania parametrów domyślnych lub też opcjonalnych po obu stronach znaku równości nie należy umieszczać żadnych spacji. Jeżeli parametry w definicji nam się nie mieszczą 80 znakach, to możemy bez trudu połamać tą linię za przecinkiem, dać dwa znaki tabulatora aby nie zostało to potraktowane jako blok funkcji i kontynuować zapisywanie parametrów na końcu zamykając nawias, podając znak dwukropka. Jeśli przechowujemy naszą funkcję w module i  ta funkcja nie jest jedyna w tym module, to możemy poszczególne funkcje w module rozdzielić dwoma pustymi wierszami.
		</p>
		<p>
			Nazwa klasy powinna stosować styl CamelCase: każde słowo nazwy pisane wielką literą, brak znaków podkreślenia. Z kolei nazwy egzemplarzy klas powinny być zapisane małymi literami, a wykorzystanie w tych nazwach znaków podkreślenia między słowami jest dopuszczalne. Na początku każdej klasy należy umieścić komentarz typu docstring wyjaśniający przeznaczenie klas znajdujących się w danym module. W kodzie klasy umieszczamy pusty wiersz pomiędzy metodami. Klasy w module rozdzielamy dwoma pustymi wierszami.
		</p>
		<p>
			Importując moduły z biblioteki standardowej oraz swoje, w pierwszej kolejności należy podać polecenia import modułów biblioteki a dopiero później swoje moduły.
		</p>
		<p>
			Ostatnim pojęciem ze stylów będzie <strong>refaktoryzacja</strong>. Jest to podział dużego kodu na funkcje wykonujące zazwyczaj konkretne zadanie.
		</p>
		<p>
			Tutaj kończy się część pierwsza, czyli poznawanie Pythona, jego składni, poleceń i konstrukcji. Teraz przejdziemy do konkretnego zagadnienia, gdzie raczej będziemy analizować studium przypadku. Przypadku tworzenia aplikacji internetowej, podobnej do tej jaką tworzy się za pomocą takich języków jak np. PHP.
		</p>
		<h2 style="text-align: center;"><strong>Koniec części pierwszej.</strong></h2>

		<hr />

		<h2 class="text-align: center"><strong>Aplikacje internetowe</strong></h2>

		<p>
			<strong>Django</strong> to zestaw narzędzi (czyt. <strong>framework</strong>) pozwalający na tworzenie aplikacji internetowych/interaktywnych witryn za pomocą Pythona.
		</p>
		<p>
			Tworząc witrynę czy też aplikacje w Django, tworzymy projekt. Każdy projekt składa się z wielu  mniejszych części zwanych <strong>aplikacjami</strong> stworzonych za pomocą Pythona według zasad Django. Każdy porządny projekt powinien mieć jasno określone założenia, na których skupiają się programiści podczas pracy, taki określony zbiór cech i funkcjonalności nazywamy specyfikacją.
		</p>
		<p>&nbsp;</p>
		<h2>Środowisko wirtualne</h2>
		<p>
			Rozpoczynając pracę z Django musimy skonfigurować <strong>środowisko wirtualne</strong>, w którym będziemy mogli dowolnie instalować rzeczy, nie powodując bałaganu w modułach Pythona na naszym systemie. Każde środowisko można bez problemu usunąć wydając odpowiednie dla systemu polecenie powłoki służące do usuwania plików. W tej części będę przedstawiał polecenia z systemu Linux, dystrybucji opartych o Debian, takich jak np. Ubuntu. Przepraszam za pominięcie innych systemów. Konfiguracje środowiska wirtualnego zaczynamy od zainstalowania modułu w systemie.
		</p>
<pre class="code-block">
$ sudo apt install python3-venv
</pre>
		<p>
			Po zainstalowaniu pakietu, dla większego porządku tworzymy sobie katalog, w którym będziemy przechowywać nasz projekt. Wewnątrz katalogu wydajemy poniższe polecenie.
		</p>
<pre class="code-block">
$ python3 -m venv project_env
</pre>
		<p>
			Za <code class="code-inline">project_env</code> możemy podstawić swoją nazwę. Po wydaniu tego polecenia Python utworzy katalog <em>project_env</em>, w którym będą przechowywane wszystkie pliki utworzonego środowiska wirtualnego. Na tym konfiguracji się kończy. Kiedy chcemy uruchomić nasze środowisko wydajemy poniższe polecenie.
		</p>
<pre class="code-block">
$ source project_env/bin/activate
</pre>
		<p>
			Polecenie powinno zakończyć działanie zaraz po uruchomieniu nie zwracając żadnych danych. Jedyną rzeczą, która się zmieni jest <em>prompt</em> (znak zachęty), przednim będzie znajdował się nawias, zawierający nazwę naszego katalogu ze środowiskiem wirtualnym.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:/python/django$
</pre>
		<p>
			Środowisko możemy wyłączyć wydając polecenie:
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:/python/django$ deactivate
</pre>
		<p>
			lub po prostu zamykając powłokę, w której je aktywowaliśmy. Po uruchomieniu środowiska będziemy używać polecenia <code class="code-inline">python</code>, to polecenie będzie odnosić się do wersji Pythona jakiej użyliśmy to stworzenia środowiska, w tym przypadku <strong>nie będziemy używać polecenia <em>python3</em></strong>. Teraz możemy przejść do instalacji Django. Wydajemy polecenie w aktywowanym środowisku wirtualnym:
		</p>
		<p>&nbsp;</p>
		<h2>Podstawy pracy z frameworkiem Django</h2>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ pip install django
</pre>
		<p>
			Kiedy polecenie skończy działanie, przechodzimy do utworzenia naszego projektu. Powiedzmy że stworzymy stronę pizzerii, gdzie będzie można zamówić pizzę i przejrzeć menu dla zamówień telefonicznych. Aby utworzyć projekt wydajemy poniższe polecenie.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ django-admin.py startproject pizzeria .
</pre>
		<p>
			W tym poleceniu najważniejsza jest <strong>kropka na końcu</strong>, powodująca że projekt zostanie utworzony w katalogu, w którym się znajdujemy. Brak kropki spowoduje utworzenie projektu w jeszcze jednym wewnętrznym katalogu. Spoglądając na pliki umieszczone w naszym folderze powinniśmy dostrzec plik <em>manage.py</em>, folder środowiska wirtualnego, zakończony sufiksem <em>_env</em>, oraz folder o nazwie <em>pizzeria</em> zawierający pliki naszego projektu.
		</p>
		<p>
			Jak wszyscy wiemy, aplikacje internetowe często przetwarzają jakieś dane. Te dane należy gdzieś składować, najpopularniejszą metodą magazynowania danych przez aplikacje sieci WWW są <strong>bazy danych</strong>. Django również korzysta z baz danych, a my wykorzystamy najprostszą z nich, w postaci jednego pliku - bazy<strong> SQLite3</strong>. W przypadku innych systemów bazodanowych niezbędna będzie instalacja dodatkowych modułów Pythona. Na tym etapie po prostu stworzymy bazę danych dla naszego projektu aby wszystko funkcjonowało poprawnie. Wydajemy polecenie:
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py migrate
</pre>
		<p>
			W Django, czynności na bazie wykonujemy za pomocą opcji <code class="code-inline">migrate</code> skryptu <em>manage.py</em>. Teraz kiedy nasza baza nie istnieje, polecenie <em>migrate</em> spowoduje jej utworzenie. Teraz możemy uruchomić nasz <strong>serwer aplikacji</strong>. Wydajemy polecenie:
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py runserver
</pre>
		<p>
			Po uruchomieniu tego polecenia, z danych przez nie zwracanych powinniśmy dowiedzieć się że nasz serwer <strong>nasłuchuje na pętli zwrotnej</strong> (<em>localhost</em>) <strong>na porcie 8000</strong>. Możemy przejść pod ten adres za pomocą przeglądarki, a naszym oczom ukaże się strona domyślna projektu, predefiniowana przez Django.
		</p>
		<p>
			Jak wiemy z początkowych akapitów, na projekt w Django składają się mniejsze części nazywane aplikacjami, często odpowiadają one za konkretne rzeczy. Teraz stworzymy aplikacje odpowiedzialną za nasze pizze i ich dodatki.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py startapp pizzas
</pre>
		<p>
			Po wykonaniu tego polecenia na chwilę się zatrzymamy. Na początku wyświetlimy sobie zawartość utworzonego katalogu aplikacji.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ ls pizzas
admin.py  __init__.py  models.py    templates  urls.py
apps.py   migrations   __pycache__  tests.py   views.py
</pre>
		<p>
			Katalogiem <em>templates</em> zajmiemy się później, natomiast katalog <em>__pycache__</em> nie jest w ogóle istotny, jest tworzyny przez Python podczas uruchamiania skryptu. Każda aplikacja w Django reprezentuje wzorzec <strong>model-view-template</strong>, na <strong>modele</strong> składają się reprezentacje danych w postaci klas. Weźmy sobie zatem taką pizzę, co może ją opisać? Na przykład nazwa. Każda pizza ma swoją nazwę, mamy zatem jakąś właściwość, która składa się na ten model, modele posiadają także metodę, która pozwala na reprezentowanie danego modelu. Kiedy wyciągniemy egzemplarz modelu z bazy, to odwołując się do niego uzyskamy, jakąś wartość. Może być to po prostu nazwa. Z technicznego punktu widzenia modele to klasy potomne, klasy <code class="code-inline">Model</code> z modułu<em> django.db.models</em>. Wewnątrz tej klasy znajdują się atrybuty, oraz metoda <code class="code-inline">__str__</code>.
			Modele przypominają tabele relacyjnych baz danych, nawet są do nich konwertowane podczas <strong>migracji</strong>, każda właściwość takiego modelu staje się kolumną w bazie. Modele definiujemy w pliku <em>models.py</em> w folderze aplikacji, a tak przedstawia się model naszej pizzy.
		</p>
<pre class="code-block">
class Pizza(models.Model):
    name = models.CharField(max_length=30)

    def __str__(self):
        return self.name
</pre>
		<p>
			W powyższym przykładzie mamy jeden atrybut znakowy (<code class="code-inline">CharField</code>) o długość 30 znaków. Odpowiada to MySQL-owemu <em>VARCHAR(30)</em>. Mamy również w naszej klasie metodę odpowiadającą za reprezentacje danego modelu. W tym wypadku zwracamy po prostu nazwę. Modele mogą być ze sobą połączone. Rozważmy przykład, posiadamy model pizzy i mamy model dodatku na pizzę, teraz chcieli byśmy dowiedzieć się jakie są dodatki dla konkretnej pizzy, aby metaforycznie położyć dodatki na pizzy skorzystamy z tak zwanego klucz obcego lub klucza zewnętrznego - odniesienia się do innego modelu.
		</p>
<pre class="code-block">
class Toping(models.Model):
    pizza = models.ForeignKey(Pizza, on_delete=models.CASCADE)
    name = models.CharField(max_length=200)

    def __str__(self):
        return self.name
</pre>
		<p>
			Za nasze połączenie opowiada metoda <code class="code-inline">ForeignKey</code>, która jako argumenty pobiera nazwę modelu, do którego będzie odnosić się właściwość <code class="code-inline">pizza</code>, drugi argument jest zachowaniem, w przypadku usunięcia egzemplarza pizzy, do którego odnoszą się egzemplarze dodatków, kiedy jest ustawiony na <code class="code-inline">models.CASCADE</code>, to gdy usuniemy pizzę to również powiązane z nią dodatki zostaną usunięte.
		</p>
		<p>
			Kiedy mamy już zdefiniowane modele, to możemy je teraz wstawić do naszej bazy. Przed przeprowadzeniem migracji, trzeba ją najpierw przygotować. Jednak przed przygotowaniem migracji, należy na początku <strong>zainstalować</strong> naszą aplikacje, aby Python wiedział że <code class="code-inline">pizzas</code> należy do projektu <em>pizzeria</em> i mógł w bazie danych projektu utworzyć tabele. Instalacja przebiega w następujący sposób, otóż w katalogu projektu odszukujemy plik <em>settings.py</em>. W nim szukamy zmiennej <code class="code-inline">INSTALLED_APPS</code>, a następnie umieszczamy nazwę naszej aplikacje w pojedynczych apostrofach na samym początku listy. Musimy <strong>pamiętać o przecinku po nazwie aplikacji. </strong>
		</p>
<pre class="code-block">
INSTALLED_APPS = [
    'pizzas',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
</pre>
		<p>
			Dlaczego umieściliśmy naszą aplikacje, na samym początku listy? Lista zawiera aplikacje domyślnie instalowane przez Django w naszym projekcie aby zapewnić mu podstawową funkcjonalność, oraz zaoszczędzić czas na tworzenie aplikacji. Aplikacje te realizują identyczne zadania dla każdego projektu. Może jednak zdarzyć się tak że będzie trzeba nadpisać funkcje domyślnej aplikacji, dlatego też swoje aplikacje dopisujemy <strong>powyżej</strong> aplikacji domyślnych. Aby przygotować migrację wydajemy poniższe polecenie:
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py makemigrations pizzas
</pre>
		<p>
			Jeśli modele są poprawne pod względem składni, to przez skrypt zostaniemy poinformowani mniej więcej takim komunikatem.
		</p>
<pre class="code-block">0001_initial.py ... OK</pre>
		<p>
			Ten komunikat oznacza również wygenerowanie <strong>plik migracji</strong>. Wydajemy poniższe polecenie aby zatwierdzić nasze zmiany w bazie:
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py migrate
</pre>
		<p>
			Wywołanie tego polecenia spowoduje utworzenie modeli. Warto zaznaczyć w tym momencie że <strong>każda poważniejsza zmiana w modelu musi zostać zatwierdzona w bazie</strong>. Każdą zmianę na modelach możemy próbować migrować, najwyżej Python nie wygeneruje pliku migracji, ponieważ uzna że zmiana, którą wprowadziliśmy nie była istotna dla modelu w bazie. Najlepiej kiedy jednak tworzymy model postarać się przemyśleć każdą właściwość, ponieważ zmiany wprowadzane w trakcie jego działania są nieco bardziej skomplikowane. Zostały one (dodawnie kolumny) opisane pod koniec strony podczas zabezpieczania naszego projektu. Przypuszczam że zmiany w bloku metody <em>__str__</em> są takim zmianami, których nie trzeba zatwierdzać w bazie.
		</p>
		<p>
			Po dokonaniu migracji, możemy wprowadzić dane początkowe do naszych modeli, do wprowadzania danych początkowych, możemy posłużyć się <strong>witryną administracyjną</strong> dostarczaną nam przez Django. Jednak przed samym rozpoczęciem musimy wykonać dwie czynności. Pierwszą rzeczą jest utworzenie konta <strong>superużytkownika</strong> - użytkownika witryny administracyjnej. Wydajemy poniższe polecenie:
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py createsuperuser
</pre>
		<p>
			Skrypt zapyta nas o kilka rzeczy. Mianowicie o nazwę użytkownika, która może zostać domyślna - nazwa użytkownika systemowego, który wydał polecenie utworzenia superużytkownika. Adres skrzynki mailowej, który jest opcjonalny. Ostatnią rzeczą jaką będziemy musieli podać to hasło. Dwukrotnie aby je potwierdzić. Po utworzeniu superużytkownika, możemy przejść do drugiej czynności.
		</p>
		<p>
			Aby móc zarządzać danym z modeli za pomocą witryny administracyjnej, należy je najpierw <strong>zarejestrować</strong>.  Modele rejestrujemy w pliku <em>admin.py</em>. Na początku importujemy nasz moduł z modelami za pomocą linii:
		</p>
<pre class="code-block">
from .models import Pizza,Toping
</pre>
		<p>
			<strong>Kropka przed <code class="code-inline">models</code></strong> oznacza że Python ma wziąć moduł z tego samego katalogu, w którym znajduje się interpretowany plik <em>admin.py</em>. Następnie przy pomocy metody <code class="code-inline">register()</code> obiektu <code class="code-inline">admin.site</code> rejestrujemy każdy z zaimportowanych modeli.
		</p>
<pre class="code-block">
admin.site.register(Pizza)
admin.site.register(Toping)
</pre>
		<p>
			Po zarejestrowaniu modeli możemy uruchomić nasz serwer deweloperski.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py runserver
</pre>
		<p>
			Otwieramy w przeglądarce następujący adres <strong>http://127.0.0.1:8000/admin</strong> . Następnie logujemy się na konto superużytkownika. Po zalogowaniu zobaczymy dwie sekcje w jednej są nasze modele, a w drugie modele użytkowników i grup. Na co chciałbym zwrócić uwagę, to fakt że nazwy modeli są zapisane w liczbie mnogiej. My tych zapisów nie generowaliśmy, Python sam sobie wywnioskował (dodał literę 's' i tyle). Jednak wiemy że tworzenie odmian nazw języków ludzi w świecie komputerów od zawsze było problemem. Tak jest i w tym przypadku. Załóżmy że mamy (tylko tak dla przykładu), model o nazwie 'Entry'. Liczba mnoga od 'Entry' to 'Entries'. Python domyślnie stworzy 'Entrys'. Oczywiście zostało to przewidziane. W celu zdefiniowania prawidłowej nazwy dla liczby mnogiej możemy użyć <strong>podklasy</strong> (klasy w klasie, nie mylić z klasą potomną) <strong>Meta</strong>, która definiuje tak jakby atrybuty opisujące samą klasę, w niej definiujemy atrybut <em>verbose_name_plural</em>.
			Pamiętajmy o tym że klasa <strong><em>Meta</em> musi być zawarta w innej klasie</strong>.
		</p>
		<p>
			Wracając do dodawania danych do modeli za pomocą witryny administracyjnej. Dane dodajemy przy użyciu plusika - zostaniemy przeniesieni bezpośrednio do formularza wprowadzającego dane do bazy,  albo klikając na nazwę modelu - zostaniemy przeniesieni do strony zawierającej egzemplarze tego modelu, gdzie klikamy przycisk "Add &lt;nazwa_modelu&gt; +". Kiedy dodamy jakiś egzemplarz (wypełniając formularz i klikając przycisk <em>"save"</em>), to podglądając listę egzemplarzy modelu to <strong>dane odnośnie egzemplarza jakie widzimy są właśnie wynikiem działania metody <em>__str__</em></strong>. Jak widać panuje pełna dowolność, co zostanie nam przestawione jako reprezentacja danego modelu.
		</p>
		<p>
			Po dodaniu danych, możemy przejść do <strong>powłoki Django</strong>. Tę powłokę możemy wykorzystać (a nawet powinniśmy) testowania zapytań do bazy. Powłokę uruchamiamy poleceniem.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py shell
</pre>
		<p>
			Przed przystąpieniem do wydawania zapytań, należy zaimportować do powłoki niezbędne nam modele. Najprostsze zapytanie wygląda następująco.
		</p>
<pre class="code-block">
# Import modeli
from pizzas.models import Pizza, Toping

pizzas = Pizza.objects.all()
</pre>
		<p>
			W poleceniu <code class="code-inline">from</code>, <code class="code-inline">pizzas</code> jest nazwą aplikacji. Zmienna <code class="code">pizzas</code> będzie przechowywać listę (tzw. <em>query set</em>) wszystkich rekordów z tabeli (egzemplarzy modelu).  Aby pobrać konkretny rekord użyjemy innej metody. Metoda <code class="code-inline">get()</code> pobiera jako argument warunek, na podstawie którego ma wybrać danych rekord, jeśli nie podamy warunku, to zostanie zgłoszony błąd że funkcja zwróciła więcej niż jeden egzemplarz.
		</p>
<pre class="code-block">
pepperoni = Pizza.objects.get(name='Pepperoni')
</pre>
		<p>
			Teraz mając jeden rekord w zmiennej, mamy możliwość sprawdzenia jakie są dodatki na naszej pizzy, odwołując się do innego modelu za pomocą naszego klucza zewnętrznego/obcego.
		</p>
<pre class="code-block">
pepperoni_tops = pepperoni.toping_set.all()
</pre>
		<p>
			Aby odwołać się do innego modelu za pomocą klucza obcego, używamy atrybutu naszej wydobytej już pizzy (bo to jej dodatki chcemy obejrzeć), który jest <strong>obiektem o nazwie składającej się z nazwy modelu do, którego się odwołujemy, napisanego za pomocą małych</strong> <strong>liter</strong> (<strong>Uwaga, zapis nazwy modelu małymi literami jest istotny!</strong>)<strong>,</strong> <strong>zakończonego sufiksem (przyrostkiem) <code class="code-inline">_set</code></strong> oraz metody, która wydobędzie nam rekordy. Tak wydobyte dane możemy sobie posortować, do sortowania służy metoda <code class="code-inline">order_by()</code> jako argument przyjmuje nazwę pola według jakiego ma sortować zwracane dane. Nazwę pola umieszczamy jako ciąg tekstowy, czy to w apostrofach, czy w cudzysłowie, <strong>wynik sortowania możemy odwrócić, stawiając minus (<code class="code-inline">-</code>) przed nazwą pola, nadal w ciągu tekstowym</strong>.
		</p>
<pre class="code-block">
pepperoni_tops = pepperoni.toping_set.order_by('-name')
</pre>
		<p>
			Powłoka w naszej pracy z Django będzie odgrywać ważną rolę, dzięki niej możemy testować nasze zapytania zanim umieścimy je w widokach, co jest znacznie lepszym rozwiązaniem a niżeli używanie nie pewnych zapytań.
		</p>
		<p>
			Kiedy mamy omówione modele oraz zapytania to teraz możemy przejść do tworzenia naszych stron aplikacji. Tworzenie stron aplikacji możemy podzielić na trzy czynności: <strong>mapowanie adresów URL</strong>, utworzenie<strong> widoku</strong> oraz utworzenie<strong> szablonu strony</strong>. Skupimy się w tym momencie na stronie głównej. Strona główna powinna zostać wyświetlona, kiedy użytkownika poda adres strony np. https://terminallog.morketsmerke.net. Kiedy my podamy teraz adres naszego serwera dostaniem stronę z informacją o tym że nasz projekt Django jest gotowy do pracy. Aby moc mapować nasze adresy na konkretne strony, musimy przekierować adres serwera w pliku <em>urls.py</em> w katalogu naszego projektu na plik mapowania URL (<em>urls.py</em>) w katalogu naszej aplikacji. Jakby jeszcze tego było mało <strong>Django mapując URL-e, całkowicie ignoruje adres serwera</strong>.
		</p>
		<p>
			Na początku w katalogu naszej aplikacji <em>pizzas</em> tworzymy plik o nazwie <em>urls.py</em>. Wewnątrz pliku importujemy funkcje <code class="code-inline">path</code> z modułu <code class="code-inline">django.urls</code> oraz importujemy widoki (o widokach za chwilę). Następnie definiujemy zmienną <code class="code-inline">app_name</code> z nazwą aplikacji, pozwoli nam to na łatwe tworzenie odnośników, do innych podstron tej aplikacji, następnie wewnątrz listy <code class="code-inline">urlpatterns</code> deklarujemy nasze mapowania, zawartość pliku powinna wyglądać mniej więcej tak.
		</p>
<pre class="code-block">
"""Definiuje wzorce adresów URL dla pizzas."""

from django.urls import path

from . import views

app_name='pizzas'
urlpatterns = [
    path('', views.index, name='index'),
]
</pre>
		<p>
			<strong>Funkcja <code class="code-inline">path</code></strong> przyjmuje jak widzimy powyżej trzy argumenty. <strong>Pierwszy z nich, jest ciąg który zostanie przekazany przez przeglądarkę w momencie żądania danej strony</strong>. Teraz ten ciąg jest pusty, ponieważ po przez adres serwera będziemy żądać strony głównej naszej aplikacji. <strong>Drugim argument jest funkcja widoku, której zadaniem jest przetworzenie i przygotowanie danych do użycia w szablonie</strong>, <strong>jeśli mówimy o czynnościach jakie wykonuje dana aplikacja internetowa w Django, to mówimy o czynnościach wykonywanych właśnie przez kod zdefiniowany ciele funkcji widoku</strong>, przeważnie jedna podstrona to jedna funkcja widoku. Funkcja widoku jest uruchamiana w momencie gdy żądanie zostanie dopasowane do pierwszego argumentu funkcji <em>path</em>. <strong>Ostatnim argumentem jest nazwa zmiennej używana przy tworzeniu odnośników w szablonach, Python podstawi wartość pierwszego parametru jeśli tworząc odnośnik odwołamy się do tej zmiennej</strong>.
		</p>
		<p>
			Po zdefiniowaniu mapowania, czas na drugą czynność. Na zdefiniowanie kodu funkcji widoku. Przechodzimy do pliku <em>views.py</em> następnie tworzymy nową funkcję o nazwie <em>index</em> przyjmującej parametr o nazwie <em>request</em>. Z racji tego że jest to strona główna, to będzie się ona opierać głównie na szablonie. Więc tutaj nasza funkcja widoku, będzie mieć tylko jedną linę, kiedy otworzymy plik <em>views.py</em> pierwsza linia zawiera import funkcji <code class="code-inline">render</code>, odpowiada ona za wygenerowanie gotowego pliku HTML z szablonu, który zrozumie każda przeglądarka. Funkcja <em>render</em> przyjmuje w tym przypadku dwa argumenty. Żądanie przechowywane w parametrze <code class="code-inline">request</code> oraz ścieżkę dostępu do szablonu. Plik <em>views.py</em> powinien wyglądać następująco.
		</p>
<pre class="code-block">
from django.shortcuts import render

# Create your views here.

def index(request):
    """Strona główna aplikacji Pizzas"""
    return render(request, 'pizzas/index.html')
</pre>
		<p>
			Ze ścieżką dostępu do szablonu jest o tyle zabawnie że, aby szablon był widziany przez Django musi być umieszczony w katalogu aplikacji następnie w podkatalogu <em>templates</em>, w którym znajduje się kolejny podkatalog o nazwie aplikacji, a w nim dopiero szablon. Pliki szablonów to tak naprawdę pliki HTML, które zawierają <strong>znaczniki szablonu</strong>, dzięki którym możemy wprowadzać nasze dane na strony witryny, ale również w prosty sposób nią zarządzać. Szablon strony głównej nie zawiera wiele informacji, nie zawiera nawet żadnego znacznika szablonu.
		</p>
<pre class="code-block">
&lt;p&gt;Pizzeria&lt;/p&gt;

&lt;p&gt;Aplikacja ta pozwala na przymowanie zamówień oraz wyświetlanie menu pizzerii&lt;/p&gt;
</pre>
		<p>
			Z racji tego że mamy trochę za mało informacji, aby zaprezentować duże możliwości szablonów w Django, rozbudujemy trochę naszą aplikacje o jedną podstronę zawierającą menu naszej pizzerii.
		</p>
		<p>
			Naszą rozbudowę zaczniemy od stworzenia szablonu w którym to będą znajdować się same odnośniki do naszych podstron, Inne szablony będą dziedziczyć te elementy od niego. W naszym katalogu z szablonami tworzymy plik o nazwie <em>base.html</em>. Plik zawiera w sumie dwie linijki
		</p>
<pre class="code-block">
&lt;a href="{% url 'pizzas:index' %}"&gt;Pizzeria&gt;/a&lt;

{% block content %}{% endblock content %}
</pre>
		<p>
			<strong>Znacznik szablonu <code class="code-inline">url</code> w atrybucie <em>href</em> wstawi bezwzględny adres URL zawierający wzorzec przypisany do nazwy <code class="code-inline">index</code> w funkcji <em>path</em> w pliku <em>urls.py</em></strong>. Po przeniesieniu tytułu jako odnośnika do szablonu nadrzędnego. Możemy teraz wpisać linię ustawiającą<strong> dziedziczenie w szablonie</strong> <em>index.html</em>. Linię wstawiamy na samej górze.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}
</pre>
		<p>
			Kiedy mamy już odpowiednie miejsce gdzie będziemy umieszczać odnośniki do naszych podstron. Możemy przejść teraz do utworzenia widoku naszej podstrony, naszą stronę nazwiemy klasycznie <code class="code-inline">menu</code>. W pliku <em>views.py</em> naszej aplikacji <em>pizzas</em>, umieszczamy poniższy kod.
		</p>
<pre class="code-block">
def menu(request):

    from pizzas.models import Pizza,Toping

    pizzas = Pizza.objects.all()

    pizza_dict={}
    pizzas_list=[]

    class PizzaClass():
        def __init__(self, name, topings):
            self.name = name
            self.topings = topings

    for pizza in pizzas:
        pizza_name = f"{pizza}"
        topings = pizza.toping_set.all()
        t=""
        for toping in topings:
            if len(t) == 0:
                t=f"{toping}, "
            else:
                t=f"{t}{toping}, "
        t=t.rstrip(', ')
        some_pizza = PizzaClass(pizza_name, t)
        pizzas_list.append(some_pizza)

    pizza_dict['pizzas']=pizzas_list

    return render(request, 'pizzas/menu.html', pizza_dict)
</pre>
		<p>
			Przed przystąpieniem do objaśniania chciałbym przestawić model wyświetlania danych, otóż chciałem uzyskać taki sam lub zbliżony ulotkom z pizzerii wydruk menu, czyli:
		</p>
		<p>
			<strong>nazwa_pizzy - składniki/dodatki</strong>
		</p>
		<p>
			A więc problem nie był kod widoku, ponieważ tu mogliśmy zbudować kod realizujący to samo zadanie w znacznie prostszy sposób, ale kod szablonu. Znaczniki szablonu mają duże możliwości, jednak nie są pełnym odwzorowaniem tego co można zrobić w Pythonie. Rozwiązanie było banalne. Mamy listę z nazwami pizz, uruchamiamy pętle, wewnątrz tej iteracji, odwołujemy się nazwą pizzy do listy składników i problem rozwiązany. Jednak w szablonach Django, jedyne co możemy zrobić z zmiennymi to nadać im wartość i wypisać. Nie możemy użyć zmiennej szablonu jako klucza aby odwołać się do kolejnej listy w zagnieżdżonej pętli <code class="code-inline">for</code>. Używanie zmiennej <em>context</em> w szablonie zakończyło się fiaskiem, mogliśmy pisać kod szablonu, który niczego nie generował. Zajrzałem więc do oficjalnej dokumentacji Django, rozwiązanie od razu nie przypadło mi do gustu, słownik + lista+ obiekty, jednak jak możemy się o tym przekonać rozwiązanie działa.
			Słownik w tym przypadku jest strukturą danych przekazywaną do szablonu za sprawą funkcji <code class="code-inline">render</code>, lista jest strukturą dzięki, której może odbyć się iteracja przez nasze pizze, obiekty pizzy został użyty w celu spięcia nazwy pizzy oraz jej dodatków w jednej strukturze, do której będziemy mogli się odwołać w szablonie. Za pewne istnieje inne rozwiązanie, jednak jeśli drogi czytelniku w życiu stworzyłeś może jeden program w Pythonie, przeczytałeś całą pierwszą część Crash Course (uwaga wykonując większość ćwiczeń, wszystkich nie trzeba ponieważ się powtarzają, ewentualnie trzeba zmienić jedną rzecz jednak logika pozostaje ta sama) i dotarłeś aż tutaj to moja umiejętność programowania w Pythonie jest mniej więcej na Twoim poziomie. Tak więc co się dzieje w widoku, już tłumaczę. Na początku importujemy nasze modele, żeby było skąd dane pobrać. Wydane zostaje zapytanie do modelu <code class="code-inline">Pizza</code> o wszystkie (egzemplarze modelu) rekordy, tworząc listę naszych pizz.
			Tworzymy klasę naszej pizzy, klasa będzie zawierać tylko metodę <code  class="code-inline">__init__</code> a oraz dwie właściwości nazwę oraz dodatki jako ciągi tekstowe Przeprowadzając iteracje, z elementu naszej listy pizz tworzymy nazwę pizzy po prostu przechowując ją w zmiennej jako ciąg tekstowy, pobieramy listę naszych dodatków odwołując się kluczem obcym pizzy do modelu <code class="code-inline">Toping</code>. Przerabiamy listę dodatków na ciąg tekstowy. Po utworzeniu listy dodatków jako ciągu możemy, zacząć tworzyć obiekty. Nowo utworzone obiekty trafiają do listy i tak kończy się iteracja. Na samym końcu dodajmy naszą listę obiektów do słownika, który w ostatniej linii naszego widoku jest przekazywany do szablonu za pomocą funkcji <code class="code-inline">render</code>. Poniżej znajduje się kod naszego szablonu.
		</p>
<pre class="code-block">
{% extends 'pizzas/index.html' %}

{% block content %}

&lt;p&gt;Menu&lt;/p&gt;

&lt;ul&gt;
    {% for pizza in pizzas %}
        &lt;li&gt;
            {{ pizza.name }}
            &lt;small&gt;- {{ pizza.topings }}&lt;/small&gt;
        &lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;


{% endblock content %}
</pre>
		<p>
			W tym momencie powinniśmy mieć gotowe menu. Teraz przygotujemy stronę, która wyświetli nam listę dodatków każdej z pizzy, abyś mogli zobaczyć jak działa <strong>przekazywanie danych do aplikacji za pomocą adresu URL</strong>
		</p>
		<p>
			Naszą rozbudowę rozpoczęliśmy od utworzenia widoku dla nowej strony. Widok jak widać poniżej jest bardzo prosty.
		</p>
<pre class="code-block">
def pizza_site(request, pizza_id):

    from pizzas.models import Pizza,Toping

    context = {}

    name = Pizza.objects.get(id=pizza_id)
    topings = name.toping_set.all()

    context['name'] = name
    context['topings'] = topings

    return render(request, 'pizzas/pizza_site.html', context)
</pre>
		<p>
			<strong>Zwrócić uwagę należy na dodatkowy parametr przekazywany do widoku. Parametr o nazwie <code class="code-inline">pizza_id</code> będzie przekazywali za pomocą adresu URL, taki parametr definiuje się we wzorcu adresu URL</strong>. Wzorcem zajmiemy się pod koniec naszych prac. Szablon dla tej strony został przedstawiony poniżej. Za pomocą słownika <code class="code-inline">context</code> została przekazana nazwa pizzy oraz lista z jej składnikami, nową rzeczą wprowadzoną tutaj jest <strong>znacznik szablonu <em>{% empty %</em>}</strong> oznacza on mniej więcej to że jeśli interpreter natrafi na pustą listę to możemy zdefiniować w bardzo prosty sposób komunikat o tym że składniki na tej pizzy są na życzenie.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

&lt;p&gt;{{ name }}&lt;/p&gt;
  &lt;ul&gt;
    {% for toping in topings %}
        &lt;li&gt;{{ toping }}&lt;/li&gt;
    {% empty %}
        &lt;li&gt;Dodatki na życzenie&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;

{% endblock content %}
</pre>
		<p>
			Mając już szablon możemy przejść do mapowania URL-i. W aplikacji <em>pizzas</em> w pliku <em>urls.py</em> za pomocą funkcji <code class="code-inline">path</code> dopisujemy do listy <em>urlspattern</em> kolejny wzorzec adresu.
		</p>
<pre class="code-block">
path('pizza/&lt;int:pizza_id&gt;', views.pizza_site, name='pizza_site')
</pre>
	<p>
		Stąd właśnie bierze się parametr widoku <code class="code-inline">pizza_site</code>, <strong>jeśli po <em>pizza/</em> podamy liczbę całkowitą to wywołamy widok <em>pizza_site</em> przekazując tę liczbę jako identyfikator rekordu pizzy</strong>. Wszystko świetnie, jednak nie znamy <em>id</em> pizz. Należało by stworzyć odnośnik do konkretnej pizzy w menu. W obecnej formie naszego menu próżno szukać <em>id</em>. Dlatego też musimy zmodyfikować widok <em>menu</em> dodając do naszej klasy atrybut id, który można pobrać bezpośrednio z egzemplarza modelu za pomocą notacji kropki i właściwości o nazwie <em>id</em>. Poniżej wstawiam zmieniony kod widoku <code class="code-inline">menu</code>.
	</p>
<pre class="code-block">
def menu(request):

    from pizzas.models import Pizza,Toping

    pizzas = Pizza.objects.all()

    pizza_dict={}
    pizzas_list=[]

    class PizzaClass():
        def __init__(self, id, name, topings):
            self.id = id
            self.name = name
            self.topings = topings

    for pizza in pizzas:
        pizza_name = f"{pizza}"
        topings = pizza.toping_set.all()
        t=""
        for toping in topings:
            if len(t) == 0:
                t=f"{toping}, "
            else:
                t=f"{t}{toping}, "
        t=t.rstrip(', ')
        some_pizza = PizzaClass(pizza.id, pizza_name, t)
        pizzas_list.append(some_pizza)

    pizza_dict['pizzas']=pizza_list

    return render(request, 'pizzas/menu.html', pizza_dict)
</pre>
		<p>
			Teraz musimy utworzyć nasz odnośnik w pętli w pliku szablonu menu aby pojawił się dla każdej pizzy.
		</p>
<pre class="code-block">
{% extends 'pizzas/index.html' %}

{% block content %}

&lt;p&gt;Menu&lt;/p&gt;

&lt;ul&gt;
    {% for pizza in pizzas %}
        &lt;li&gt;
            {{ pizza.name }}
            &lt;small&gt;- {{ pizza.topings }}&lt;/small&gt;
            &lt;a href="{% url 'pizzas:pizza_site' pizza.id %}"&gt;Pokaż&lt;/a&gt;
        &lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;


{% endblock content %}
</pre>
		<p>
			Podczas tworzenia adresu odnośnika za pomocą znacznika szablonu <code class="code-inline">url</code> odwołujemy się do wzorca zdefiniowanego za pomocą wartości nadanej parametrowi <em>name</em> funkcji <em>path</em><strong> </strong>w pliku <em>urls.py</em>, tym razem <strong>wartość <em>pizza_id</em>  podajemy obok odwołania się do wzorca</strong>. Teraz przy wywołaniu strony menu przy każdej z pizz powinien pokazać się odnośnik "Pokaż" kierujący nas do konkretnej strony pizzy.
		</p>
		<p>&nbsp;</p>
		<h2>Aplikacja users</h2>
		<p>
			Skoro mamy już stronę główną, mamy menu i jest z czego wybierać możemy teraz przejść do składania zamówień. Złożenie zamówienia w naszej pizzerii będzie wymagało utworzenia konta. <strong>Obsługą kont zajmie się odrębna aplikacja Users, którą teraz utworzymy</strong>. Przechodzimy do katalogu naszego projektu i wydajemy następujące polecenie:
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py startapp users
</pre>
		<p>
			Po wydaniu tego polecenia zostanie utworzona struktura plików identyczna jak dla aplikacji <em>pizzas</em>. Teraz instalujemy aplikacje <em>users</em> w identyczny sposób jak instalowaliśmy aplikacje <em>pizzas</em>.
		</p>
<pre class="code-block">
INSTALLED_APPS = [
    'pizzas',
    'users',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
</pre>
		<p>&nbsp;</p>
		<h2>Logowanie użytkowników</h2>
		<p>
			Naszą przygodę z kontami użytkowników zaczniemy od dania możliwości logowania potencjalnym klientom naszej pizzerii. Samo logowanie w Django jest banalne ponieważ korzystać będziemy z gotowego, przygotowanego przez Django widoku dla logowania. Jedynego czego będziemy potrzebować to mapowania URL oraz szablonu. Zaczniemy od mapowania. W pliku <em>urls.py</em> projektu <em>pizzeria</em> na liście <code class="code-inline">urlpatterns</code> dokonujemy takiego samego przekierowania jak w przypadku przekierowania w aplikacji <em>pizzas</em> jednak naszym wzorcem będzie <code class="code-inline">users/</code> a pliku <em>urls.py</em> będzie znajdował się w katalogu aplikacji <em>users</em> (jako argument funkcji <code class="code-inline">include</code> podajemy <code class="code-inline">users.urls</code>).
		</p>
<pre class="code-block">
urlpatterns = [
    path('admin/', admin.site.urls),
    path('users/', include('users.urls')),
    path('', include('pizzas.urls'))
]
</pre>

		<p>
			W aplikacji <em>users</em> tworzymy plik urls.py. W nim importujemy funkcje <code class="code-inline">path</code> oraz <code class="code-inline">include</code> z modułu <code class="code-inline">django.urls</code>, definiujemy <code class="code-inline">app_name</code> następnie na liście <code class="code-inline">urlpatterns</code> dodajemy jedno wywołanie funkcji <code class="code-inline">path</code> kierujące puste domyślne zapytanie do pliku zdefiniowanego przez Django <code class="code-inline">django.contrib.auth.urls</code>.
		</p>
<pre class="code-block">
from django.urls import path,include

app_name="users"
urlpatterns = [
    path('', include('django.contrib.auth.urls'))
]
</pre>
		<p>
			Teraz kiedy mapowanie jest gotowe, możemy przejść do utworzenia szablonu. Domyślna funkcja widoku stworzona do logowania generuje stronę na podstawie szablonu <em>login.html</em> umieszczonego w katalogu <strong><em>templates/registration</em>. Te nazwy muszą zostać zachowane</strong>. Utwórzmy te katalogi wewnątrz katalogu aplikacji <em>users</em>. Następnie utworzymy plik z szablonem.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

    &lt;form action="{% url 'users:login' %}" method="post"&gt;
        {% csrf_token %}
        {{ form.as_p }}
        &lt;button name="submit"&gt;Zaloguj się&lt;/button&gt;
       &lt;input type="hidden" name="next" value="{% url 'pizzas:index' %}" /&gt;
    &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			Tak prezentuje się nasz szablon logowania. Warto zwrócić uwagę na to jak <strong>łatwy jest dostęp do zasobów innej aplikacji wystarczy odpowiednia ścieżka (patrz znacznik <em>extends</em>)</strong>, w atrybucie <em>action</em> zdefiniowana została strona, która ma obsłużyć dany formularz. <strong>Znacznik szablonu <code class="code-inline">csrf_token</code> służy zabezpieczeniu formularza przez atakiem CSRF</strong>. Następnie wyświetlany jest sam formularz, który przechowywany jest w zmiennej <code class="code-inline">form</code>. Wyświetlenie jej wraz z<strong> <code class="code-inline">as.p</code> spowoduje że etykiety oraz pola wprowadzania danych zostaną wyświetlone jako jeden akapit i tak dla każdego z elementów formularza</strong>. <strong>Formularze w Django nie zawierają przycisków</strong>, trzeba je zdefiniować samemu.<strong> Ostatnią rzeczą jest przekazanie wraz z formularzem do widoku adresu strony, do której ma zostać przekierowany użytkownik po poprawnym zalogowaniu.</strong> Jako ciekawostkę możemy sobie dodać warunek w formularzu, który wyświetli nam komunikat z informacją o tym że formularz nie został poprawnie wypełniony.  W ten czas nasz formularz wyglądać będzie tak:
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

    {% if form.errors %}
        &lt;p&gt;
            Nazwa użytkownika i hasło są niepoprawne. Spróbuj ponownie.
        &lt;/p&gt;
    {% endif %}

    &lt;form action="{% url 'users:login' %}" method="post"&gt;
        {% csrf_token %}
        {{ form.as_p }}
        &lt;button name="submit"&gt;Zaloguj się&lt;/button&gt;
        &lt;input type="hidden" name="next" value="{% url 'pizzas:index' %}" /&gt;
   &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			Dlaczego jednak jako ciekawostkę? Otóż <strong>Django sam dodaje takową informacje jeśli formularz nie przejdzie walidacji</strong>. Teraz dodamy warunek w pliku w szablonie bazowym aplikacji <em>pizzas</em>, po to abyśmy wiedzieli że zostaliśmy zalogowani oraz w przeciwnym wypadku wyświetli odnośnik prowadzący do strony logowania. Poniżej znajduje się już uzupełniony kod szablonu bazowego aplikacji <em>pizzas</em>.</p>
		</p>
<pre class="code-block">
&lt;p&gt;
    &lt;a href="{% url 'pizzas:index' %}"&gt;Pizzeria&lt;/a&gt;-
    &lt;a href="{% url 'pizzas:menu' %}"&gt;Menu&lt;/a&gt;
&lt;/p&gt;

{% if user.is_authenticated %}
    &lt;p&gt;
        Witaj, {{ user.username }}
    &lt;/p&gt;
{% else %}
    &lt;p&gt;
        &lt;a href="{% url 'users:login' %}"&gt;Zaloguj się&lt;/a&gt;
    &lt;/p&gt;
{% endif %}

{% block content %} {% endblock content%}
</pre>
		<p>
			Jednego użytkownika już mamy. Możemy się zalogować się jako superużytkownik. Po poprawnym zalogowaniu zostaniemy przeniesieni do z powrotem na stronę główną, jednak teraz zamiast "Zaloguj się" zobaczymy "Witaj, pizza_admin". Teraz pod powitaniem umieścimy przycisk "Wyloguj", który będzie kończył sesję użytkownika w aplikacji. Wylogowanie również jest funkcją, która jest dostarczana wraz z Django. Mapowanie URL-u wylogowania jest również dostarczane przez Django, tak jak mapowanie URL-u logowania. Szablon bazowy wygląda następująco po dodaniu nowego odnośnika.
		</p>
<pre class="code-block">
&lt;p&gt;
    &lt;a href="{% url 'pizzas:index' %}"&gt;Pizzeria&lt;/a&gt;-
    &lt;a href="{% url 'pizzas:menu' %}"&gt;Menu&lt;/a&gt;
&lt;/p&gt;

{% if user.is_authenticated %}
    &lt;p&gt;
        Witaj, {{ user.username }}
    &lt;/p&gt;
    &lt;p&gt;
        &lt;a href="{% url 'users:logout' %}"&gt;Wyloguj&lt;/a&gt;
    &lt;/p&gt;
{% else %}
    &lt;p&gt;
        &lt;a href="{% url 'users:login' %}"&gt;Zaloguj się&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;a href="{% url 'users:register' %}"&gt;Zarejestruj się&lt;/a&gt;
    &lt;/p&gt;
{% endif %}

{% block content %} {% endblock content%}
</pre>
		<p>
			W ramach eksperymentu, kliknijmy w ten odnośnik. Zostaniemy poinformowani o wylogowaniu z naszej aplikacji przez witrynę administracyjną Django. Nie zbyt fajnie, co? Oczywiście to zachowanie możemy zmienić, tworząc nowy szablon w katalogu <em>templates/registration</em>. <strong>Uwaga!</strong> <strong>Plik musi nazywać się: logged_out.html.</strong> Po rozszerzeniu pliku o szablon bazowy, między znacznikami<em> </em>szablonu oznaczającymi zawartość strony w tym szablonie możemy umieścić wszystko co nam się podoba.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

    &lt;p&gt;
        Dziękujemy za skorzystanie z naszej aplikacji.
   &lt;/p&gt;

{% endblock content %}
</pre>
		<p>&nbsp;</p>
		<h2>Rejestracja użytkowników</h2>
		<p>
			Teraz możemy dać możliwość samodzielnego utworzenia konta na stronie naszej pizzerii. Tutaj nie jest już tak kolorowo. Jedyne co nam <strong>Django oferuje w tym przypadku jest formularz. </strong>Widok, szablon oraz mapowanie URL-u musimy utworzyć samodzielnie. Zaczynamy od widoku dla formularza rejestracji.
		</p>
<pre class="code-block">
from django.shortcuts import render, redirect
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth import login

def register(request):

    if request.method != 'POST':
        form = UserCreationForm()
    else:
        form = UserCreationForm(data=request.POST)
        if form.is_valid():
            new_user = form.save()
            login(request, new_user)
            return redirect('pizzas:index')
   content = {'form': form}
   return render(request, 'registration/register.html", context)
</pre>
		<p>
			W tym przypadku aby funkcja widoku mogła poprawnie działać oraz wyświetlać nam formularz, potrzebujemy modułów. Pierwszą funkcją jaką importujemy jest <code class="code-inline">redirect</code>, powoduje ona przekierowanie HTTP, na stronę podaną jako argument. <strong>Adresy stron podane jako argumenty funkcji <em>redirect </em>czy też w znacznikach szablonu <em>url</em> podajem w formacie <code class="code-inline">nazwa_aplikacji:nazwa_mapowania</code> - wartość argumentu <em>name</em> funkcji <em>path</em> w pliku <em>urls.py</em>.</strong> Następnie importujemy nasz formularz oraz funkcję <em>login</em>. Za pomocą tej funkcji będzie możliwe automatyczne zalogowanie nowo utworzonego użytkownika. Funkcje widoku obsługujące formularz posiadają pewien schemat. Taka funkcja rozpoczyna się od sprawdzenia użytej metody przesłania danych do serwera, protokół HTTP wyróżnia dwie <strong>GET</strong> oraz <strong>POST</strong>. Metoda <em>GET</em> służy głównie do obsługi żądań osób odwiedzających witrynę. Poniżej żądanie wyświetlenia strony konkretnej pizzy.
		</p>
<pre class="code-block">
http://localhost:8000/pizza/1
</pre>
		<p>
			Żądanie wyświetlenia konkretnej pizzy zostało przesłane do serwera za pomocą żądania <em>GET</em>. Najprościej można to ująć w ten sposób że żądania <strong><em>GET</em> są przesyłanie w adresie strony. </strong>Natomiast żądania<strong> <em>POST</em> są przesyłane oddzielnym pakietem transmisji.</strong> W żądaniach <em>POST</em> najczęsciej są przesyłane dane formularzy.
		</p>
		<p>
			Jeśli w nasz widok, ktoś wywołał za pomocą żądania <em>GET</em> to wtedy zmiennej <code class="code-inline">form</code> zostanie nadany pusty formularz. Następnie definiowana jest zmienna <code class="code-inline">context</code> zawierająca wszelkie dane dla szablonu w tym nasz formularz. Na sam koniec funkcja widoku zwraca wygenerowaną przed funkcję <code class="code-inline">render()</code> stronę, na której znajduje się nasz formularz rejestracji. W przeciwnym wypadku jeśli nasza funkcja została wywołana za pomocą żądania POST (np. kiedy użytkownik przesłał formularz), to tworzona jest zmienna z formularzem gdzie jego dane są pobierane z właściwości <code class="code-inline">POST</code> obiektu <code class="code-inline">request</code>.
			Za pomocą instrukcji warunkowej <code class="code-inline">if</code> oraz metody formularza <code class="code-inline">is_valid()</code> sprawdza jest poprawność wypełnienia pól formularza, jeśli któraś z wartości pół nie przechodzi walidacji (sprawdzenia poprawności), to następną czynnością jest wpisanie formularza do zmiennej <code class="code-inline">context</code> i wygenerowanej strony z formularzem oraz komunikatem błędu.
			Zaś kiedy formularz został wypełniony bezbłędnie to wykonywana jest metoda formularza <code class="code-inline">save()</code>, która powoduje zapisanie danych z formularza w bazie danych na podstawie przypisanego do niego modelu. Zwróćmy uwagę na to że <strong>wartość zwraca przez metodę <em>save()</em> została zapisana do zmiennej <code class="code-inline">new_user</code>. Dzięki tej zmiennej będzie możliwe automatyczne zalogowanie zarejestrowanego użytkownika</strong>, kiedy mamy tą zmienną możemy zalogować użytkownika za pomocą funkcji <code class="code-inline">login()</code> ta funkcja pobiera dwa argumenty obiekt żądania (<em>request</em>) oraz odniesienie do użytkownika (<em>new_user</em>).
			Kiedy użytkownik został zalogowany, możemy teraz przekierować go na stronę główną, która zostanie wyświetlona ze spersonalizowanym powitaniem oraz odnośnikiem do wylogowania się z konta na naszej stronie. Teraz potrzebujemy jeszcze szablonu, który poza odnośnikiem nie różni się niczym do szablonu logowania.
		</p>
		<p>
			Plik szablonu formularza rejestracji znajduje się w folderze <em>templates/registration</em> pod nazwą <em>register.html</em>:
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

    {% if form.errors %}
        &lt;p&gt;Rejestracja nie powiodła się. Spróbuj ponownie&lt;/p&gt;
    {% endif %}

    &lt;form action="{% url 'users:register' %}" method="post"&lt;
        {% csrf_token %}
        {{ form.as_p }}
        &lt;button name="submit"&gt;Zarejestruj się&lt;/button&gt;
        &lt;input type="hidden" name="next" value="{% url 'pizzas:index' %}" /&gt;
    &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			Funkcja mapowania w pliku <em>users/urls.py</em> wygląda następująco:
		</p>
<pre class="code-block">
path('register/', views.register, name="register"),
</pre>
		<p>
			Teraz możemy do szablonu bazowego aplikacji <em>pizzas</em> dodać odnośnik dla niezalogowanych, prowadzący do naszej strony z rejestracją.i
		</p>
<pre class="code-block">
&lt;p&gt;
    &lt;a href="{% url 'pizzas:index' %}"&gt;Pizzeria&lt;/a&gt;-
    &lt;a href="{% url 'pizzas:menu' %}"&gt;Menu&lt;/a&gt;
&lt;/p&gt;

{% if user.is_authenticated %}
    &lt;p&gt;
        Witaj, {{ user.username }}
    &lt;/p&gt;
    &lt;p&gt;
        &lt;a href="{% url 'users:logout' %}"&gt;Wyloguj&lt;/a&gt;
    &lt;/p&gt;
{% else %}
    &lt;p&gt;
        &lt;a href="{% url 'users:login' %}"&gt;Zaloguj się&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;a href="{% url 'users:register' %}"&gt;Zarejestruj się&lt;/a&gt;
    &lt;/p&lt;
{% endif %}

{% block content %} {% endblock content%}
</pre>
		<p>&nbsp;</p>
		<h2>Zamówienia</h2>
		<p>
			Teraz kiedy mamy logowanie oraz rejestracje. To powinniśmy mieć możliwość złożenia zamówienia w naszej pizzerii (aplikacja <em>pizzas</em>). Sama operacja jest dość złożona bo do realizacji tego zadania potrzebujemy aż 5 elementów: modelu zamówienia, widoku wyświetlającego zamówienia, widoku dodającego zamówienia, formularza, szablonu i mapowania URL. Zaczniemy od modelu zamówienia. Na nasze zamówienie będzie składać się pizza, wielkość, sos pierwszy oraz sos drugi, dowóz czy odbiór własny oraz datę zamówienia. Model prezentuje się poniżej. Stosować będziemy skróty, które nasz kucharz będzie stanie odszyfrować dlatego pola są takie małe.
		</p>
<pre class="code-block">
class Order(models.Model):

    pizza = models.ForeignKey(Pizza, on_delete=models.CASCADE)
    size = models.CharField(max_length=10)
    sauce1 = models.CharField(max_length=10)
    sauce2 = models.CharField(max_length=10)
    deliver = models.CharField(max_length=10)
    date_order = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.pizza.name} - {self.size},{self.sauce1},\
        {self.sauce2},{self.deliver} - {self.date_order}"

</pre>
		<p>
			Po dopisaniu naszego modelu zamówienia musimy wykonać migrację.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py makemigrations pizzas
(project_env) xf0r3m@macbook:python/django$ python manage.py migrate
</pre>
		<p>
			Po pomyślnej migracji zarejestrujemy nowy model na witrynie administracyjnej, po to aby dodać kilka testowych wartość do sprawdzenia widoku wyświetlania złożonych zamówień. Widok złożonych zamówień prezentuje się następująco:
		</p>
<pre class="code-block">
def orders_view(request):

    from pizzas.models import Order

    orders = Order.objects.order_by('-date_order')
    context = {'orders': orders}
    return render(request, 'pizzas/orders_view.html', context)
</pre>
		<p>
			W szablonie zamiast używać listy użyjemy tabeli. Poniżej znajduje się kod szablonu.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;td&gt;Numer zamówienia&gt;/td&gt;
            &lt;td&gt;Pizza&lt;td&gt;
            &lt;td&gt;Wielkość&lt;/td&gt;
            &lt;td&gt;Sos_1&gt;/td&gt;
            &lt;td&gt;Sos_2&lt;td&gt;
            &lt;td&gt;Dostawa&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;body&gt;
    {% for order in orders %}
        &lt;tr&gt;
            &lt;td&gt;{{ order.id }}&lt;/td&gt;
            &lt;d&gt;{{ order.pizza.name }}&lt;/td&gt;
            &lt;td&gt;{{ order.size }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce1 }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce2 }}&lt;/td&gt;
            &lt;td&gt;{{ order.deliver }}&lt;/td&gt;
        &lt;/tr&gt;
    {% empty %}
        &lt;tr&gt;&lt;td colspan="6"&gt;Brak zamówień&lt;/td&gt;&lt;/tr&gt;
    {% endfor %}
    &lt;/tbody&gt;
&lt;/table&gt;

{% endblock content %}
</pre>
		<p>
			Teraz możemy przejść do składania zamówień na naszą pizzę, zaczniemy od formularza. Nie jest on może trudny w interpretacji ale jest nieco bardziej złożony niż te przedstawione w książce.
		</p>
<pre class="code-block">
from django import forms

from .models import Order

class NewOrder(forms.ModelForm):
    class Meta:
        model = Order
        fields = ['pizza', 'size', 'sauce1', 'sauce2', 'deliver']
        labels = {
            'pizza': 'Pizza',
            'size': 'Wielkość',
            'sauce1': 'Pierwszy sos',
            'sauce2': 'Drugi sos',
            'deliver': 'Dostawa'
        }
        size_choice = [
            (None, '-----------'),
            ('S', 'Mała'),
            ('M', 'Duża'),
            ('L', 'Familijna'),
            ('XL', 'XXL 55cm')
        ]
        sauce_choice = [
            ('br', '-----------'),
            ('k', 'Ketchup'),
            ('m', 'Majonez'),
            ('cz', 'Czosnkowy'),
            ('pik', 'Pikantny')
        ]
        deliver_choice = [
            (None, '-----------'),
            ('odb', 'Odbiór osobisty'),
            ('dwz', 'Dowóz')
        ]
        widgets = {
            'size': forms.Select(choices=size_choice),
            'sauce1': forms.Select(choices=sauce_choice),
            'sauce2': forms.Select(choices=sauce_choice),
            'deliver': forms.Select(choices=deliver_choice)
        }
</pre>
		<p>
			Formularze w Django to nic innego jak klasy potomne, klasy <code class="code-inline">ModelForms</code> modułu <code class="code-inline">django.forms</code>, jednak kodu określającego formularz nie tworzymy w samej klasie potomnej tylko w pod klasie <code class="code-inline">Meta</code>. Z racji tego że klasa <em>ModelForm</em> bazuje na modelach (zresztą jak sama nazwa wskazuje) musimy pamiętać o ich imporcie jeszcze przed zdefiniowaniem samej klasy.
			W klasie <em>Meta</em> podajemy takie informacje jak <strong>model</strong> na jakim bazuje formularz (<strong>zmienna <code class="code-inline">model</code></strong>), <strong>pola formularza</strong> (<strong>lista <code class="code-inline">fields</code></strong>) oraz <strong>etykiety</strong> (<strong>słownik <code class="code-inline">labels</code></strong>), z racji tego że informacje przekazywane przez zamawiającego mogą być predefiniowane, to cały formularz oprzemy na jednym elemencie, na liście wyboru <em>select</em>.
			<strong>Jeśli nasz model zawiera klucz obcy, to pole z automatu jest ustawiane przez Django jako element <em>select</em></strong>. Resztę naszych pól musimy ustawić samodzielnie.
			<strong>Zmianie elementów przydzielanych przez Django, służy słownik <code class="code-inline">widgets</code></strong>, w której każdemu polu przypisujemy wyświetlany element, w tym przypadku jest to <code class="code-inline">forms.Select</code> czyli element HTML <em>select</em> <strong>jako argument <code class="code-inline">choices</code> podajemy listę z dwuelementowych krotek</strong>, w naszym przypadku zdefiniowaną powyżej słownika <em>widgets</em>.
			Jako ciekawostkę podam fakt, że <strong>jeśli mamy w jakieś krotce w pierwszym elemencie podamy jako pierwszy argument, czyli wartość elementu <em>option</em>, wartość <em>None</em> to pole automatycznie stanie się polem <em>required</em></strong>, czyli jego wartość musi być ustawiona inaczej przeglądarka nie pozwoli wysłać formularza. Poniżej znajduje się kod widoku obsługującego ten formularz.
		</p>
<pre class="code-block">
def new_order(request):

    if request.method != 'POST':
        form = NewOrder()
    else:
        form = NewOrder(data=request.POST)
        if form.is_valid():
            form.save()
            return redirect('pizzas:thank_you')
    context = {'form': form}
    return render(request, 'pizzas/new_order.html', context)
</pre>
		<p>
			Ten przypadek obsługi jest chyba najprostszy. Nie ma tu nic złożone, po przejściu walidacji zamówienie jest zapisywane w bazie. Pod mapowaniem <em>thank_you</em> kryje się jeden akapit z podziękowanie za złożenie zamówienia. Poniżej znajduje kod szablonu.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

    {% if form.errors %}
        &lt;p&gt;
            Złożenie zamówienia nie powiodło się. Spróbuj ponownie
       &lt;/p&gt;
    {% endif %}

    &lt;form action="{% url 'pizzas:new_order' %}" method="post"&gt;
        {% csrf_token %}
        {{ form.as_p }}
	&lt;button name="submit"&gt;Zamów&lt;/button&gt;
    &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			Powiedzmy że zamówiliśmy pizzę, ale w pizzerii skończył się jeden jej składnik. Kelnerka po kontakcie telefonicznym z klientem doszła do porozumienia i klient wybrał inną pizzę. Jednak w systemie nie ma możliwości zmiany zamówienia. Utworzymy ją. Do tego celu potrzebujemy dodatkowego widoku, mapowania, szablonu oraz odnośnika do edycji zamówienia w tabeli z zamówieniami. Edycje danych wpisywanych za pomocą formularza tworzy się bardzo szybko ponieważ wystarczy skopiować widok oraz szablon. W widoku dodać kilka rzeczy, w szablonie zmieć dwie rzecz oraz dodać jedną. Poniżej znajduje się kod widoku, najważniejszy w tym przedsięwzięciu.
		</p>
<pre class="code-block">
def edit_order(request, order_id):

    from .models import Order

    order = Order.objects.get(id=order_id)

    if request.method != 'POST':
        form = NewOrder(instance=order)
    else:
        form = NewOrder(instance=order, data=request.POST)
        if form.is_valid():
            form.save()
            return redirect('pizzas:edit_ok')
    context = {'form': form, 'order': order}
    return render(request, 'pizzas/edit_order.html', context)
</pre>
		<p>
			Zatem po kolei żeby było wiadomo jakie zamówienie mamy zmienić potrzebujemy jego identyfikatora, <em>id</em> z tabeli w bazie danych. Potrzebne nam <em>id</em> będzie przekazywane w żądaniu <em>GET</em>, przez kliknięcie w łącze na stronie z zamówieniami. Na początku naszego widoku importujemy model <code class="code-inline">Order</code>, aby uzyskać dostęp do egzemplarzy tego modelu w bazie. Za pomocą zapytania <code class="code-inline">Order.objects.get(id=order_id)</code>, pobraliśmy rekord zamówienia do zmiennej <code class="code-inline">order</code>. Następnie wykonuje się klasyczna obsługa formularza z tą jednak różnicą że kiedy tworzone są egzemplarze formularza to przekazywany jest argument <code class="code-inline">instance</code>, któremu nadawana jest wartość naszego zapytania, <strong>ustawienie argumentu <em>instance</em> powoduje wypełnienie pół formularza danymi z zapytania</strong>, strona <em>edit_ok</em> zawiera jeden akapit z informacją że zapisano zmiany w zamówieniu.
			<strong>W zmiennej <code class="code-inline">context</code> została dodana wartość obiektu <code class="code-inline">order</code> pod kluczem <code class="code-inline">order</code>. Jest to niezbędne kiedy zmieniamy rekordy, ponieważ w atrybucie <code class="code-inline">action</code> formularza musimy podać <em>id</em> zmienianego rekordu, ponieważ ten widok będzie wykonywany po raz drugi gdy użytkownik prześle dane. Dlatego też po słowie kluczowym <code class="code-inline">else</code> gdzie deklarowany jest formularz, podano argument <code class="code-inline">instance</code>, aby było wiadomo jaki rekord należy zmienić. </strong>Poniżej znajduje się kod szablonu.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

    {% if form.errors %}
        &lt;p&gt;
            Zmiana zamówienia nie powiodła się. Spróbuj ponownie
        &lt;/p&gt;
    {% endif %}

    &lt;form action="{% url 'pizzas:edit_order' order.id %}" method="post"&gt;
        {% csrf_token %}
        {{ form.as_p }}
        &lt;button name="submit"&t;Zapisz zmiany&lt;/button&gt;
    &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			Tutaj zmieniono atrybut <code class="code-inline">action</code> na <code class="code-inline">edit_order</code>, dodano <code class="code -inline">order.id</code> oraz zmieniono treść przycisku. Poniżej znajduje się zawartość pliku <em>pizzas/urls.py</em> z uwzględnieniem nowego mapowania oraz zmieniony kod szablonu <em>pizzas/orders_view.html</em>.
		</p>
		<p>
			<span style="text-decoration: underline;">Plik pizzas/urls.py</span>
		</p>
<pre class="code-block">
from django.urls import path

from . import views

app_name='pizzas'
urlpatterns = [
    path('', views.index, name='index'),
    path('menu', views.menu, name='menu'),
    path('pizza/&lt;int:pizza_id&gt;', views.pizza_site, name='pizza_site'),
    path('orders/', views.orders_view, name="orders"),
    path('new_order/', views.new_order, name="new_order"),
    path('edit_order/&lt;int:order_id&gt;', views.edit_order, name='edit_order')
]
</pre>
		<p>
			<span style="text-decoration: underline;">Plik pizzas/templates/pizzas/orders_view.html</span>
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

&lt;table border="1"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Numer zamówienia&lt;/th&gt;
            &lt;th&gt;Pizza&lt;/th&gt;
            &lt;th&gt;Wielkość&lt;/th&gt;
            &lt;th&gt;Sos_1&lt;/th&gt;
            &lt;th&gt;Sos_2&lt;/th&gt;
            &lt;th&gt;Dostawa&lt;/th&gt;
            &lt;th&gt;&gt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    {% for order in orders %}
        &lt;tr&gt;
            &lt;td&gt;{{ order.id }}&lt;/td&gt;
            &lt;td&gt;{{ order.pizza.name }}&gt;/td&gt;
            &lt;td&gt;{{ order.size }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce1 }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce2 }}&lt;/td&gt;
            &lt;td&gt;{{ order.deliver }}&lt;/td&gt;
            &lt;td&gt;&lt;a href="{% url 'pizzas:edit_order' order.id %}"&gt;Zmień&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
    {% empty %}
        &lt;tr&gt;&lt;td colspan="7"&gt;Brak zamówień&lt;/td&gt;&lt;/tr&gt;
    {% endfor %}
    &lt;tbody&gt;
&lt;/table&gt;

{% endblock content %}
</pre>
		<p>&nbsp;</p>
		<h2>Zabezpieczenie aplikacji</h2>
		<p>
			Kolejną rzeczą jak należy zrobić to zabezpieczyć pewne strony przed niepowołanym dostępem. W zależności od tego jakie restrykcje chcemy wprowadzić możemy użyć konkretnych metod. Pierwszą z nich jest wymaganie logowania, jeśli nie zalogowani przejedziemy pod adres <em>http://localhost:8000/new_order</em>. Zostanie nam przedstawiona strona do składania zamówień. W ten sposób osoba złośliwa może po nabijać zamówień, zostawiając jedynie ślad w logach o ile uruchomiliśmy serwer wraz z opcją zapisywania dziennika. Django daje nam banalny sposób na zabezpieczenie się przed tego typu sytuacjami. W pliku <em>views.py</em> w aplikacji <em>pizzas</em> importujemy <strong>dekorator</strong> (dodatek/modyfikator do funkcji) o nazwie <code class="code-inline">login_required</code>.
		</p>
<pre class="code-block">
from django.contrib.auth.decorators import login_required
</pre>
		<p>
			<strong>Dekorator <code class="code-inline">login_required</code> sprawdzi czy jesteśmy zalogowani, kiedy będziemy wywoływać funkcje widoku</strong>. <strong>Dekoratora używamy w pomocą znaku <code class="code-inline">@</code> oraz nazwy dekoratora tuż nad definicją widoku</strong>, tak jak przedstawiono to poniżej:
		</p>
<pre class="code-block">
@login_required
def orders_view(request):
    ...

@login_required
def new_order(request):
    ...

@login_required
def edit_order(request, order_id):
</pre>
		<p>
			Aby działało to poprawnie w ustawieniach projektu pizzeria/settings.py musimy zdefiniować zmienną LOGIN_URL na samym dole pliku, jeśli tego nie zrobimy niezalogowani użytkownicy, przechodzący pod zabezpieczoną przez dekorator stronę otrzymają stronę błędu, że nie znaleziono strony. <strong>Wartość zmiennej <code class="code-inline">LOGIN_URL</code> zapisujemy w klasycznym odniesieniu do strony, tak jak w przypadku znaczników szablonu url, czy funkcji redirect <em>(nazwa_aplikacji:nazwa_mapowania_URL)</em></strong>.
		</p>
<pre class="code-block">
LOGIN_URL = 'users:login'
</pre>
		<p>
			Teraz kiedy nie zalogowani, spróbujemy na przykład podejrzeć zamówienia. Zostaniemy przekierowani na stronę logowania, identycznie będzie z wywołaniem widoku <em>new_order</em>, czyli złożeniem nowego zamówienia oraz z jego edycją.
		</p>
		<p>
			Drugi sposób w jaki możemy zabezpieczyć naszą aplikacje, jest wyświetlenie użytkownikom rzeczy stricte tyczących się ich. Powiedzmy że użytkownik powinien mieć wgląd w swoje zamówienia. Ta zmiana będzie wymagać trochę pracy, ale myślę że jest ciekawy do opisania przypadek, ponieważ <strong>musimy zmienić już wdrożony model danych</strong>. Dodać jedną kolumnę do tabeli, to nie jest problem jeśli tabela była by pusta, ale co jeśli dane do tej tabeli już zostały wprowadzone dane. Zaczniemy od zaimportowania modelu User w pliku <em>pizzas/models.py</em>.
		</p>
<pre class="code-block">
from django.contrib.auth.models import User
</pre>
		<p>
			Następnie dodamy do naszego modelu <code class="code-inline">Order</code> nowe kolumnę o nazwie <code class="code-inline">owner</code>, która będzie kluczem obcym w modelu User dostarczanym przez Django.
		</p>
<pre class="code-block">
class Order(models.Model):

    pizza = models.ForeignKey(Pizza, on_delete=models.CASCADE)
    size = models.CharField(max_length=10)
    sauce1 = models.CharField(max_length=10)
    sauce2 = models.CharField(max_length=10)
    deliver = models.CharField(max_length=10)
    date_order = models.DateTimeField(auto_now_add=True)
    owner = models.ForeignKey(User, on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.pizza.name} - {self.size},{self.sauce1},\
        {self.sauce2},{self.deliver} - {self.date_order}"
</pre>
		<p>
			Aby wdrożyć nasze zmiany musimy wykonać migrację.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py makemigrations pizzas
</pre>
		<p>
			Podczas wykonywania tego polecenia<strong> Python wyświetli informacje o tym że próbujemy dodać nie-zerowe pole do modelu <em>Order</em> bez wartości domyślnej i nie jest to możliwe, ponieważ zmiany muszą być również uwzględnione na istniejących już rekordach.</strong> Python daje nam do wyboru dwie opcje, albo podanie teraz wartość jaka zostanie przypisana w polu <em>owner</em> dla istniejących już rekordów, lub porzucenie migracji i dodanie wartości domyślnej w deklaracji pola w klasie modelu.
		</p>
<pre class="code-block">
You are trying to add a non-nullable field 'owner' to order without a default; we can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit, and let me add a default in models.py
Select an option: 2
</pre>
		<p>
			Teraz wybierzemy opcje nr. 2. Jeśli podczas testowania rejestracji stworzyliśmy użytkownika to możemy mu nadać wszystkie zamówienia, <strong><em>models.ForeignKey()</em> zawiera identyfikatory (<em>id</em>) z zewnętrznej tabeli</strong>. Aby dowiedzieć się jakie <em>id</em> mają nasi użytkownicy skorzystamy z pomocy powłoki Django.
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ python manage.py shell
</pre>
<pre class="code-block">
&gt;&gt;&gt; from django.contrib.auth.models import User
&gt;&gt;&gt; users = User.objects.all()
&gt;&gt;&gt; for user in users:
...     print(f"{user.id} {user.username}")
...
1 pizza_admin
2 xf0r3m
</pre>
		<p>
			Na początku importujemy nasz model, następnie pobieramy wszystkie egzemplarze tego modelu aby poprzez iteracje wpisać <em>id</em> oraz nazwę użytkownika. Teraz wiemy że nasz stworzony w celach testowych użytkownik ma <em>id</em> = 2.  Oczywiście moglibyśmy to pominąć i domyślić się że musi mieć <em>id</em> = 2. Jednak chciałem przedstawić tutaj sposób w jaki możemy to sprawdzić aby mieć pewność. Również możemy wyszukać użytkownika za pomocą lekko zmodyfikowanego zapytania.
		</p>
<pre class="code-block">
&gt;&gt;&gt; user = User.objects.get(username='xf0r3m')
&gt;&gt;&gt; user.id
2
</pre>
		<p>
			Teraz kiedy znamy już <em>id</em> możemy ponownie wydać polecenie migracji. Python znów nas zapyta o to samo, jednak teraz wybieramy opcje nr. 1 a następnie po znaku zachęty <em>&gt;&gt;&gt;</em> wpiszemy <em>id</em> naszego użytkownika.
		</p>
<pre class="code-block">
You are trying to add a non-nullable field 'owner' to order without a default;
we can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows
 	with a null value for this column)
 2) Quit, and let me add a default in models.py
Select an option: 1
Please enter the default value now, as valid Python
The datetime and django.utils.timezone modules are available,
so you can do e.g. timezone.now
Type 'exit' to exit this prompt
&gt;&gt;&gt; 2
</pre>
		<p>
			Teraz zmodyfikujemy widok <code class="code-inline">order_views</code>, tak aby wyświetlał zamówienia wszystkich użytkowników, jeśli zalogowanym użytkownikiem jest <code class="code-inline">pizza_admin</code>, czyli nasz superużytkownik. A jeśli zalogowany jest kto inny, to widzi on tylko swoje zamówienia.
		</p>
<pre class="code-block">
@login_required
def orders_view(request):

    from pizzas.models import Order

    if request.user.username != 'pizza_admin':
        orders = Order.objects.filter(owner=request.user).order_by('-date_order')
    else:
        orders = Order.objects.order_by('-date_order')


    context = {'orders': orders}
    return render(request, 'pizzas/orders_view.html', context)
</pre>

		<p>
			Ważną rzeczą użytą w tym przypadku jest to iż <strong>egzemplarz klasy User zalogowanego użytkownika jest przechowywany w właściwości <code class="code-inline">user</code> obiektu <code class="code-inline">request</code></strong>. Jednak chcąc przyrównać nazwy użytkowników musimy użyć właściwości <em>username</em>. Ze względu na iż zmodyfikowaliśmy model <em>Order</em> teraz nie możliwe jest dodanie nowego zamówienia bez zmian uwzględniających właściciela. Poniżej znajduje się kod widoku new_order uwzględniający właściciela.
		</p>
<pre class="code-block">
@login_required
def new_order(request):

    if request.method != 'POST':
        form = NewOrder()
    else:
        form = NewOrder(data=request.POST)
        if form.is_valid():
            new_order = form.save(commit=False)
            new_order.owner = request.user
            new_order.save()
            return redirect('pizzas:index')
    context = {'form': form}
    return render(request, 'pizzas/new_order.html', context)
</pre>
		<p>
			Z założeń wynika iż użytkownik raz przypisany do zamówienia jest nietykalny, nie musimy w ogóle zmieniać kodu widoku <em>edit_order</em>.  Wprowadziłem lekką zmianę do szablonu <em>orders_view.html</em> aby wyświetlał datę, według narzuconego formatu.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

&lt;table border="1"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Numer zamówienia&lt;/th&gt;
            &lt;th&gt;Pizza&lt;/th&gt;
            &lt;th&gt;Wielkość&lt;/th&gt;
            &lt;th&gt;Sos_1&lt;/th&gt;
            &lt;th&gt;Sos_2&lt;/th&t;
            &lt;th&gt;Dostawa&lt;/th&gt;
            &lt;th&gt;Data zamówienia&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    {% for order in orders %}
        &lt;tr&gt;
            &lt;td&gt;{{ order.id }}&lt;/td&gt;
	    &lt;td&gt;{{ order.pizza.name }}&lt;/td&gt;
            &lt;td&gt;{{ order.size }}&lt;/td&gt;
	    &lt;td&gt;{{ order.sauce1 }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce2 }}&lt;/td&gt;
            &lt;td&gt;{{ order.deliver }}&lt;/td&gt;
            &lt;td&gt;{{ order.date_order|date:'d M Y H:i'  }}&lt;/td&gt;
	    &lt;td&gt;&lt;a href="{% url 'pizzas:edit_order' order.id %}"&gt;Zmień&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
    {% empty %}
        &lt;tr&gt;&lt;td colspan="7"&gt;Brak zamówień&lt;/td&gt;&lt;/tr&gt;
    {% endfor %}
    &lt;/tbody&gt;
&lt;/table&gt;

{% endblock content %}
</pre>
		<p>
			<strong>Pionowa kreska <code class="code-inline">|</code> oraz <code class="code-inline">date:'d M Y H:i'</code> są to filtry znaczników szablonu, w tym przypadku jest filtr daty, który wyświetla nam date w formacje 01 Jan 1970 00:00. </strong>
		</p>
		<p>
			Aby upewnić się ze wszystko działa utwórzmy trzeciego użytkownika i złóżmy zamówienie. Użytkownicy powinni widzieć tylko swoje zamówienia, z kolei superużytkownik powinien widzieć je wszystkie. Ostatnią rzeczą jaka pozostała do zabezpieczenia, jest wyłączność na edycje zamówień przez superużytkownika. Zwykli użytkownicy nie powinni mieć dostępu do zmiany zamówienia. Zmian musimy dokonać w dwóch miejscach: w szablonie oraz w widoku <em>edit_order</em>. Najpierw rozpoczniemy od szablonu. Poniżej zmieniony kod szablonu
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block content %}

&lt;table border="1"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Numer zamówienia&lt;/th&gt;
            &lt;th&gt;Pizza&lt;/th&gt;
            &lt;th&gt;Wielkość&lt;/th&gt;
            &lt;th&gt;Sos_1&lt;/th&gt;
            &lt;th&gt;Sos_2&lt;/th&gt;
            &lt;th&gt;Dostawa&lt;/th&gt;
            &lt;th&gt;Data zamówienia&lt;/th&gt;
        {% if user.username == 'pizza_admin' %}
            &lt;th&gt;&lt;/th&gt;
        {% endif %}
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    {% for order in orders %}
        &lt;tr&gt;
            &lt;td&gt;{{ order.id }}&lt;/td&lt;
            &lt;td&gt;{{ order.pizza.name }}&lt;/td&gt;
            &lt;td&gt;{{ order.size }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce1 }}&lt;/td&lt;
            &lt;td&gt;{{ order.sauce2 }}&lt;/td&gt;
            &lt;td&gt;{{ order.deliver }}&lt;/td&gt;
            &lt;td&gt;{{ order.date_order|date:'d M Y H:i'  }}&lt;/td&gt;
            {% if user.username == 'pizza_admin' %}
                &lt;td&gt;&lt;a href="{% url 'pizzas:edit_order' order.id %}"&gt;Zmień&lt;/a&gt;&lt;/td&gt;
            {% endif %}
        &lt;/tr&gt;
    {% empty %}
        &lt;tr&gt;&lt;td colspan="7"&gt;Brak zamówień&lt;/td&gt;&lt;/tr&gt;
    {% endfor %}
    &lt;/tbody&gt;
&lt;/table&gt;

{% endblock content %}
</pre>
		<p>
			Dodaliśmy dwa znaczniki warunkowe szablonu, sprawdzające czy uwierzytelniony użytkownik to <code class="code-inline">pizza_admin</code >. Teraz zajmiemy się kodem widoku, na początek importujemy dwie rzeczy z modułu <code class="code-inline">django.http</code>.
		</p>
<pre class="code-block">
from django.http import HttpResponseRedirect, Http404
</pre>
		<p>
			Następnie w kodzie widoku <strong>dopisujemy warunek, który przyrówna <code class="code-inline">request.user.username</code> do ciągu <code class="code-inline">pizza_admin</code> jeśli się te wartości nie będą się zgadzać wtedy zostanie zgłoszony wyjątek <code class="code-inline">Http404</code></strong>. Poniżej znajduje się kod zmodyfikowanej funkcji widoku.
		</p>
<pre class="code-block">
@login_required
def edit_order(request, order_id):

    if request.user.username != 'pizza_admin':
        raise Http404

    from .models import Order

    order = Order.objects.get(id=order_id)

    if request.method != 'POST':
        form = NewOrder(instance=order)
    else:
        form = NewOrder(instance=order, data=request.POST)
        if form.is_valid():
            form.save()
            return redirect('pizzas:index')
    context = {'form': form, 'order': order}
    return render(request, 'pizzas/edit_order.html', context)
</pre>
		<p>&nbsp;</p>
		<h2>Nadawanie stylu aplikacji - Bootstrap4</h2>
		<p>
			Przed nami ostatni rozdział podróży przez Pythona oraz przez Django. Zostały jeszcze dwa zagadnienia, które należało by omówić w kontekście Django. Nadawanie stylu oraz oraz wdrożenie naszej aplikacji na <strong>platformie sieciowej Heroku</strong>. Zaczniemy od nadawania stylu, aby nasza aplikacja zaczęła wyglądać bardziej profesjonalnie za pomocą znanego zestawu narzędzi jakim jest <strong>Bootstrap 4</strong>. Dla nasze aplikacji skorzystamy z prostego motywu. Na początku instalujemy dodatek zawierający Bootstrap przygotowany do współpracy z Django . W aktywnym środowisku wirtualnym wydajemy polecenie:</p>
		</p>
<pre class="code-block">
(project_env) xf0r3m@macbook:python/django$ pip install django-bootstrap4
</pre>
		<p>
			Po zainstalowaniu Bootstrap, dopisujemy go zainstalowanych aplikacji w naszym projekcie. Plik <em>pizzeria/settings.py</em>, zmienna <code class="code-inline">INSTALLED_APPS</code>.
		</p>
<pre class="code-block">
INSTALLED_APPS = &#91;
    'users',
    'pizzas',
    'bootstrap4',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
</pre>
		<p>
			Teraz kiedy nasz Bootstrap jest już zainstalowany. Możemy podmienić kod z szablonu <em>base.html</em> na ten poniżej.
		</p>
		<p>
			Najprościej rzecz ujmując, ten szablony stworzy bazową stronę naszej aplikacji. Na górze strony zostanie umieszczony responsywny pasek nawigacyjny, zawierający wszystkie nasze dotychczasowe odnośniki oraz nazwę aplikacji. Responsywność wygląda w ten sposób że jeśli strona zostanie wyświetlona na wąskim ekranie, odnośniki zostaną schowane w wysuwanym na dół menu. A na pasku zostanie wyświetlona nazwa aplikacji czy już w tym przypadku projektu oraz przycisk aktywujący wysunięcie menu. Poniżej znajduje się kod szablonu bazowego.
		</p>
<pre class="code-block">
{% load bootstrap4 %}

&lt;!doctype html&gt;
&lt;html lang="pl"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"&gt;
        &lt;title&gt;Pizzas&gt;/title&lt;
        {% bootstrap_css %}
        {% bootstrap_javascript jquery='full' %}
    &lt;/head&gt;
    &lt;body&lt;
        &lt;nav class="navbar navbar-expand-md navbar-light bg-light mb-4 border"&gt;
            &lt;a class="navbar-brand" href="{% url 'pizzas:index' %}"&lt;
                Dolce&amp;Gusto
            &lt;/a&gt;
            &lt;button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"&gt;
                &lt;span class="navbar-toggler-icon"&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;div class="collapse navbar-collapse" id="navbarCollapse"&gt;
                &lt;ul class="navbar-nav ml-auto"&gt;
                    {% if user.is_authenticated %}
                        &lt;li class="nav-item"&lt;
                            &lt;span class="navbar-text"&gt;
                                Witaj, {{ user.username }}
                            &lt;/span&gt;
                        &lt;/li&gt;
                        {% if user.username == 'pizza_admin' %}
                            &lt;li class="nav-item"&gt;
                                &lt;a class="nav-link" href="{% url 'pizzas:orders' %}"&gt;
                                    Zamówienia
                                &lt;/a&gt;
                            &lt;/li&gt;
                        {% else %}
                            &lt;li class="nav-item"&gt;
                                &lt;a class="nav-link" href="{% url 'pizzas:new_order' %}"&gt;
                                    Złóż zamówienie
                                &lt;/a&gt;
                            &lt;/li&gt;
                            &lt;li class="nav-item"&gt;
                                &lt;a class="nav-link" href="{% url 'pizzas:orders' %}"&gt;
                                    Moje zamówienia
                                &lt;/a&gt;
                            &lt;/li&gt;
                        {% endif %}
                        &lt;li class="nav-item"&gt;
                            &lt;a class="nav-link" href="{% url 'users:logout' %}"&gt;
                                Wyloguj
                            &lt;/a&gt;
                        &lt;li&gt;
                    {% else %}
                        &lt;li class="nav-item"&gt;
                            &lt;a class="nav-link" href="{% url 'users:register' %}"&gt;
                                Rejestruj
                            &lt;/a&gt;
                        &lt;/li&gt;
                        &lt;li class="nav-item"&gt;
                            &lt;a class="nav-link" href="{% url 'users:login' %}"&gt;
                                Zaloguj
                            &lt;/a&lt;
                        &lt;/li&gt;
                    {% endif %}
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/nav&gt;
        &lt;main role="main" class="container"&gt;
            &lt;div class="pb-2 mb-2 border-bottom"&lt;
                {% block page_header %} {% endblock page_header %}
            &lt;/div&gt;
            &lt;div&gt;
                {% block content %}{% endblock content %}
            &lt;/div&gt;
        &lt;/main&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
		<p>
			W tym szablonie <strong>na samy początku ładujemy Bootstrap4</strong> aby mieć możliwość skorzystania ze znaczników szablonu przygotowanych przez tę aplikację. Następnie tworzona jest podstawowa struktura strony HTML, z zaznaczeniem użycia języka polskiego w atrybucie <code class="code-inline">lang</code> w znaczniku otwierającym HTML, w nagłówku strony - pomiędzy znacznikami <code class="code-inline">head</code>, przekazywane są informacje odpowiedzialne za kodowanie strony <code class="code-inline">&lt;meta charset="utf-8"&gt;</code>, responsywność <code class="code-inline">&lt;meta name="viewport" ...&gt;</code>, ustawienie tekstu wyświetlanego w tytule karty lub/i okna przeglądarki <code class="code-inline">&lt;title&gt;&lt;/title&gt;</code>.
			Następnie mamy <strong>dwa znaczniku szablonu Django, w których to ładowane są pliki arkusza stylów CSS oraz biblioteki JavaScript ze wskazaniem o użyciu pełnej biblioteki, a nie wersji odchudzonej (nie zawierającej obsługi AJAX-a oraz efektów - takich rzeczy jak np. slideToggle)</strong>.
		 	W ciele strony - między znacznikami <code class="code-inline">&lt;body&gt;</code> umieszczamy nasz pasek nawigacyjny <code class="code-inline">&lt;nav ...&gt;</code>. Na pasku nawigacyjnym umieszczamy odnośnik do strony głównej zatytułowany nazwą projektu w Django, przycisk widoczny jedynie na małych ekranach, zwężonych oknach przeglądarki lub dużych zoomach, powodujący wyjechanie menu ukrytego w wyżej wymienionych sytuacjach zaraz pod przyciskiem znajduje się  znajduje się sekcja <code class="code-inline">&lt;div&gt;</code> z menu przedstawionym tutaj za pomocą listy nieuporządkowanej. Wewnątrz listy znajdują się znaczniki szablonu oraz odnośniki znane nam z poprzedniej wersji pliku <em>base.html</em>. Pod paskiem nawigacji znajduje się element główny naszej strony, zwierający dwa znaczniki sekcji.
			Pierwszy z nich zawiera, <strong>parę znaczników szablonu <code class="code-inline">block page_header</code>, dzięki temu zdefiniowany na innej stronie znaczniki <em>block page_header</em> zostanie wstawiony w to miejesce</strong>, nieco enigmatyczne wydają się użyte w tej sekcji klasy, pierwszy z nich <code class="code-inline">pb-2</code> oznacza wewnętrzny odstęp dolny treści elementu krawędzi elementu (<em>padding-bottom</em>) o wielkości <code class="code-inline">$spacer</code> * 0,5, gdzie <em>$spacer</em> (zmienna SASS - język pre procesora kompilowany do CSS) przyjmuje wartość 16px. klasa <em>pb</em> istnieje w 5 wariantach. od * 0,25 od * 3. Identycznie jest z drugą klasą, tylko że zamiast dopełnienia (odstęp pomiędzy treścią elementu a jego krawędzią), mamy margines czyli odstęp między krawędzią elementu a krawędzią następnego elementu, w naszym przypadku mamy margines dolny, ponieważ po literce <code class="code-inline">m</code> występuje literka <code class="code-inline">b</code> następnie po myślniku mamy warjant, klasa border-bottom powoduje nałożenie stylów zdefiniowanych w tej klasie na dolną krawędź elementów.
			Nie ma co rozwodzić się na wszystkimi użytymi tym przykładzie klasami. Ponieważ ten kod w 90% został zaczerpnięty z przykładów znajdujących się po tym adresem <a href="https://getbootstrap.com/docs/4.5/examples/">https://getbootstrap.com/docs/4.5/examples/</a> jedne co zostało zmienione to podział elementu <code class="code-inline">main</code> na dwie sekcje div i nadanie większego odstępu pierwszej sekcji od drugie wyżej wymienionymi stylami. Teraz nadamy styl stronie głównej.
		</p>
		<p>
			Poniżej prezentuje się kod szablonu strony głównej, w przeciwieństwie do poprzedniego nie jest tak obszerny.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block page_header %}
&lt;div class="jumbotron"&gt;
    &lt;div class="container"&gt;
      &lt;h1 class="display-3"&gt;Dolce&amp;Gusto&lt;/h1&gt;
      &lt;p&gt;Pyszna pizza tylko na dowóz. Zamów już dziś.&lt;/p&gt;
      &lt;p&gt;&gt;a class="btn btn-primary btn-lg" href="{% url 'users:register' %}" role="button"&lt;Zarejestruj się &amp;raquo;&lt;/a&gt;&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
{% endblock page_header %}
</pre>
		<p>
			Tutaj zostaje wykorzystany blok <code class="code-inline">page_header</code> aby umieścić element nazwany przez Bootstap Jumbotronem. Jest to wyróżniający się duży prostokąt, przeważnie z dużym tytułem, drobnym opisem oraz łączem w postaci przycisku. "&amp;raquo;" to encja HTML (encje zawierają znaki specjalnej, cięzko jest wpisać za pomocą klawiatury) przedstawiąca dwa połączone znaki większości lub jak kto woli dwa prawe ostre nawiasty "»" . Przycisk kieruje na formularz rejestracji, teraz sobie obstylujemy formularze. Styl dla formularzy rejestracji będzie taki podstawowy, a styl dla formlarza logowania weźmiemy z przykładów na stronie Bootstrap
		</p>
		<p>
			Poniżej znajduje się kod formularza rejestracji, jest to klasyczny książkowy przykład nadawania formularzom w Django stylów Bootstrap4.
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}
{% load bootstrap4 %}

{% block page_header %}
    &lt;h2&gt;Rejestracja&lt;/h2&gt;
{% endblock page_header %}

{% block content %}

    &lt;form action="{% url 'users:register' %}" method="post"&gt;

        {% csrf_token %}
        {% bootstrap_form form %}
        {% buttons %}
            &lt;button name="submit" class="btn btn-primary"&gt;Zarejestruj się&lt;/button&gt;
        {% endbuttons %}

        &lt;input type="hidden" name="next" value="{% url 'pizzas:index' %}" /&gt;
    &lt;/form&lt;

{% endblock content %}
</pre>
<p>
	Ten formularz będzie nieco inny, dodamy obraz w bloku <code class="code-inline">page_header</code>. Musimy dodać również dostosowane dlatego tego formularza style. <strong>W tym przykładzie warto zwrócić uwagę na to że nie wykorzystaliśmy formularza przygotowanego przez Django, skorzystaliśmy jedynie z nazw pól odpowiednich dla formularza </strong>i przesłaliśmy nasz spersonalizowany formularz. Kod jest nieco obszerny.
</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block page_header %}
    &lt;img src="https://i.imgur.com/olxvhk5.jpg" style="width: 100%;" /&gt;
{% endblock page_header %}

{% block content %}
&lt;style&gt;
.form-signin {
  width: 100%;
  max-width: 330px;
  padding: 15px;
  margin: auto;
}
.form-signin .checkbox {
  font-weight: 400;
}
.form-signin .form-control {
  position: relative;
  box-sizing: border-box;
  height: auto;
  padding: 10px;
  font-size: 16px;
}
.form-signin .form-control:focus {
  z-index: 2;
}
.form-signin input[type="email"] {
  margin-bottom: -1px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.form-signin input[type="password"] {
  margin-bottom: 10px;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}
&lt;/style&gt;

    {% if form.errors %}
    &lt;div class="alert alert-danger alert-dismissible fade show" role="alert"&gt;
        Niepoprawny login lub hasło. Spróbuj ponownie.
        &lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;
          &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;
        &lt;/button&lt;
      &lt;/div&gt;
    {% endif %}

    &lt;form class="form-signin" action="{% url 'users:login' %}" method="post"&gt;
        {% csrf_token %}
        &lt;h1 class="h3 mb-3 font-weight-normal text-center"&gt;Zaloguj się&lt;/h1&gt;
        &lt;label for="username" class="sr-only"&gt;Nazwa użytkownika&lt;/label&gt;
        &lt;input type="text" id="username" name="{{form.username.html_name}}" class="form-control" placeholder="Nazwa użytkownika" required autofocus&gt;
        &lt;label for="form.password" class="sr-only"&gt;Hasło&lt;/label&gt;
        &lt;input type="password" id="password" name="{{form.password.html_name}}" class="form-control" placeholder="Hasło" required&gt;
        &lt;button class="btn btn-lg btn-primary btn-block" type="submit"&gt;Zaloguj&lt;/button&gt;
        &lt;p class="mt-5 mb-3 text-muted text-center"&gt;&amp;copy; 2020&lt;/p&gt;
        &lt;input type="hidden" name="next" value="{% url 'pizzas:index' %}" /&gt;
    &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			Z racji tego iż nasz formularz jest dostosowywany. Musieliśmy też dodać również własny komunikat o tym że logowanie się nie powiodło. Alert z możliwością zamknięcia znajduje się w pomiędzy warunkowymi znacznikami szablonu. Do obstylowania pozostała jeszcze tabelka z zamówieniami, formularz zamówienia, edycja zamówienia, menu, strona pizzy oraz strona wylogowania. Poniżej znajdują sią szablony obstylowanych już stron.
		</p>
		<p>
			<span style="text-decoration: underline;">Strona podglądu zamówień:</span>
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block page_header %}
    &lt;img src="https://i.imgur.com/olxvhk5.jpg" style="width: 100%;" /&lt;
{% endblock page_header %}

{% block content %}

&lt;table class="table"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th scope="col"&gt;Nr zamówienia&lt;/th&gt;
            &lt;th scope="col"&gt;Pizza&lt;/th&gt;
            &lt;th scope="col"&gt;Wielkość&lt;/th;&gt;
            &lt;th scope="col"&gt;Sos_1&lt;/th&gt;
            &lt;th scope="col"&gt;Sos_2&lt;/th&gt;
            &lt;th scope="col"&gt;Dostawa&lt;/th&gt;
            &lt;th scope="col"&gt;Data zamówienia&lt;/th&gt;
        {% if user.username == 'pizza_admin' %}
            &lt;th&gt;&lt;/th&gt;
        {% endif %}
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    {% for order in orders %}
        &lt;tr&gt;
            &lt;th scope="row"&gt;{{ order.id }}&lt;/th&gt;
            &lt;td&gt;{{ order.pizza.name }}&gt;/td&lt;
            &lt;td&gt;{{ order.size }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce1 }}&lt;/td&gt;
            &lt;td&gt;{{ order.sauce2 }}&lt;/td&gt;
            &lt;td&gt;{{ order.deliver }}&lt;/td&gt;
            &lt;td&lt;{{ order.date_order|date:'d M Y H:i'  }}&lt;/td&gt;
            {% if user.username == 'pizza_admin' %}
                &lt;td&gt;&lt;a href="{% url 'pizzas:edit_order' order.id %}"&gt;Zmień&lt;/a&gt;&lt;/td&gt;
            {% endif %}
        &lt;/tr&gt;
    {% empty %}
        &lt;tr&gt;&lt;td colspan="7"&gt;Brak zamówień&lt;/td&gt;&lt;/tr&gt;
    {% endfor %}
    &lt;/tbody&gt;
&lt;/table&gt;

{% endblock content %}
</pre>
		<p>
			<span style="text-decoration: underline;">Strona formularza zamówień</span>:
		</p>
<pre class="code-block">{% extends 'pizzas/base.html' %}
{% load bootstrap4 %}

{% block page_header %}
    &lt;img src="https://i.imgur.com/olxvhk5.jpg" style="width: 100%;" /&gt;
{% endblock page_header %}

{% block content %}

    &lt;form action="{% url 'pizzas:new_order' %}" method="post"&gt;
        {% csrf_token %}
        {% bootstrap_form form %}
        {% buttons %}
            &lt;button name="submit" class="btn btn-primary"&gt;Zamów&lt;/button&gt;
        {% endbuttons %}
    &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			Warto zaznaczyć że usunięto znacznik warunkowy, który wyświetlał informacje, o ile zapisanie zmian się nie powiodło, otóż jeśli wyświetlenie formularza pozostawiamy Bootstrapowi, to on sam wyświetli komunikat jeśli w formularzu pojawią się błędy.
		</p>
		<p>
			<span style="text-decoration: underline;">Strona edycji zamówień:</span>
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}
{% load bootstrap4 %}

{% block page_header %}
    &gt;img src="https://i.imgur.com/olxvhk5.jpg" style="width: 100%;" /&gt;
{% endblock page_header %}


{% block content %}

    &lt;form action="{% url 'pizzas:edit_order' order.id %}" method="post"&gt;
        {% csrf_token %}
        {% bootstrap_form form %}
        {% buttons %}
        &lt;button name="submit" class="btn btn-primary"&gt;Zapisz zmiany&lt;/button&gt;
        {% endbuttons %}
    &lt;/form&gt;

{% endblock content %}
</pre>
		<p>
			<span style="text-decoration: underline;">Strona menu:</span>
		</p>
<pre class="code-block">
{% extends 'pizzas/index.html' %}

{% block page_header %}
    &lt;img src="https://i.imgur.com/olxvhk5.jpg" style="width: 100%;" /&gt;
{% endblock page_header %}

{% block content %}

&lt;table class="table"&gt;
    &lt;thead&lt;
        &lt;th scope="col"&gt;Pizza&lt;/th&gt;
        &lt;th scope="col"&gt;Składniki&lt;/th&gt;
        &lt;th scope="col"&gt;&lt;/th&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {% for pizza in pizzas %}
        &lt;tr&lt;
            &lt;th scope="row"&gt;{{ pizza.name }}&lt;/td&gt;
            &lt;td&gt;{{ pizza.topings }}&lt;/td&gt;
            &lt;td&gt;&lt;a href="{% url 'pizzas:pizza_site' pizza.id %}"&gt;Wybierz&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
    {% empty %}
        &lt;tr&gt;Nie ustalono jeszcze menu&lt;/tr&gt;
    {% endfor %}
    &lt;/tbody&gt;
&lt;/table&gt;


{% endblock content %}
</pre>
		<p>
			<span style="text-decoration: underline;">Strona pizzy:</span>
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block page_header %}
    &lt;img src="https://i.imgur.com/olxvhk5.jpg" style="width: 100%;" /&gt;
{% endblock page_header %}

{% block content %}

&lt;h2&gt;{{ name }}&lt;/h2&gt;

&lt;ul class="list-group list-group-flush"&gt;
    {% for toping in topings %}
        &lt;li class="list-group-item"&gt;{{ toping }}&lt;li&gt;
    {% empty %}
        &lt;li class="list-group-item"&gt;Dodatki na życzenie&gt;/li&gt;
    {% endfor %}
&lt;/ul&gt;

{% endblock content %}
</pre>
		<p>
			<span style="text-decoration: underline;">Strona wylogowania:</span>
		</p>
<pre class="code-block">
{% extends 'pizzas/base.html' %}

{% block page_header %}
    &lt;img src="https://i.imgur.com/olxvhk5.jpg" style="width: 100%;" /&gt;
{% endblock page_header %}


{% block content %}

&lt;div class="alert alert-primary" role="alert"&gt;
    Dziękujemy za skorzystanie z naszej aplikacji.
  &lt;/div&gt;



{% endblock content %}
</pre>
		<p>&nbsp;</p>
		<h2>Platforma Heroku</h2>
		<p>
			Teraz kiedy mamy obstylowaną naszą aplikacje, możemy wrzucić ją na <strong>platformę sieciową Heroku</strong>. Wdrożenie danych na platformę Heroku, będzie wymagało trochę zachodu. Na początku sprawdzimy czy w naszym systemie są obecne pakiety, które umożliwią kompilacje instalowanego przez <em>pip</em> oprogramowania. Poniższa procedurę testowano na Ubuntu LTS Desktop 20.04, w terminalu wydajemy następujące polecenie.
		</p>
<pre class="code-block">
$ sudo apt install python3-psycopg2 python3-dev libpq-dev postgresql-server-dev-all build-essential
</pre>
		<p>
			Powyższe polecenie zainstaluje wybrane pakiety jeśli, któregoś brakuje w systemie. Aby móc w ogóle pracować z Heroku potrzebujemy założyć sobie na platformie konto, aby to zrobić przechodzimy pod ten adres: <a href="https://signup.heroku.com/">https://signup.heroku.com/</a>.
		</p>
		<p>
			Po założeniu konta możemy zainstalować heroku w naszym systemie.
		</p>
<pre class="code-block">
$ sudo snap install --classic heroku
</pre>
		<p>
			Kiedy nasze oprogramowanie zostanie zainstalowane, możemy przejść do katalogu naszą aplikacją i uruchomić środowisko wirtualne.
		</p>
<pre class="code-block">
$ cd python/django3
python/django3 $ source blog_env/bin/activate
</pre>
		<p>
			W środowisku wirtualnym instalujemy wymagane poniższe pakiety.
		</p>
<pre class="code-block">
(blog_env) python/django3 $ pip install wheel
(blog_env) python/django3 $ pip install psycopg2
(blog_env) python/django3 $ pip install django-heroku
(blog_env) python/django3 $ pip install gunicorn
</pre>
		<p>
			Aby nasza aplikacja mogła działać na platformie Heroku w sposób identyczny jak na komputerze lokalnym, musi mieć zainstalowane takie samo oprogramowanie jakie instalowaliśmy przez <code class="code-inline">pip</code> do tej pory. Nie było tego dużo, django oraz django-bootstrap4. Jednak Heroku nie rozwiąże sobie zależności samodzielnie, dlatego na liście trzeba uwzględnić wszystko razem z zależnościami, to zadanie możemy wykonać jednym poleceniem.
		</p>
<pre class="code-block">
(blog_env) python/django3 $ pip freeze > requirements.txt
</pre>
		<p>
			<strong>Plik musi nazywać <em>requirements.txt</em></strong>. Tak wygląda jego zawrtość:
		</p>
<pre class="code-block">
asgiref==3.2.10
beautifulsoup4==4.9.1
dj-database-url==0.5.0
Django==3.1
django-bootstrap4==2.2.0
django-heroku==0.3.1
gunicorn==20.0.4
psycopg2==2.8.5
pytz==2020.1
soupsieve==2.0.1
sqlparse==0.3.1
whitenoise==5.2.0
</pre>
		<p>
			<strong>Uwaga! </strong>Może się zdarzyć że w tym pliku znajdzie się taka linia: <code class="code-inline">pkg-resources==0.0.0</code>. Należy ją usunąć, gdyż nasz projekt nie zostanie zbudowany na Heroku, bo nie będzie mógł odnaleźć takiej zależności. Ta linia nie jest istotna, została wpisana do pliku przez błąd <code class="code-inline">pip</code>.
		</p>
		<p>
			Po utworzeniu listy zależności należy wskazać Heroku, jakiej <strong>wersji Pythona</strong> ma używać dla naszego projektu, wersje sprawdzimy poniższym poleceniem.
		</p>
<pre class="code-block">
(blog_env) python/django3 $ python --version
Python 3.8.2
</pre>
		<p>
			<strong>Natomiast zawtość pliku <em>runtime.txt</em></strong> <strong>(nazwa pliku musi być identyczna)</strong> musi wyglądać następująco:
		</p>
<pre class="code-block">
python-3.8.2
</pre>
		<p>
			<strong>Python z małej litery i myślnik zamiast spacji</strong>. Nastepnym a zarazem ostatnim potrzebnym nam plikiem, będzie plik stricte Heroku <em><strong>Procfile</strong></em>, w nim zostanie zdefiniowany proces maszyny wirtualnej odpowiedzialny za hostowanie naszego projektu.
		</p>
		<p>
			<span style="text-decoration: underline;">Zawrtość pliku Procfile</span>
		</p>
<pre class="code-block">
web: gunicorn blog.wsgi --log-file -
</pre>
		<p>
			Teraz kiedy mamy wszystkie pliki możemy dopisać ustawienia dla Heroku w naszym projekcie. W głównym katalogu projektu w pliku <em>settings.py</em> na samym końcu pliku dopisujemy poniższe linie.
		</p>
<pre class="code-block">
import django_heroku
django_heroku.settings(locals())
</pre>
		<p>
			Aby móc synchronizować nasz kod źródłowy z platformą Heroku skorzystamy z systemu kontroli wersji<strong> Git</strong>. Git w dużym skrócie tworzy zatwierdzenie (<em>commit</em>) zmian w kodzie, które są tak jakby oddzielną jego wersją. Projekty tworzą repozytoria, w których przechowywane są zatwierdzenia, każda nowa funkcjonalność może być (nawet dobrze, gdyby była) kolejnym zatwierdzeniem. Daje nam to możliwość powrotu do poprzedniej wersji w razie problemów. Git jest obecnie standardem zarządania kodem źródłowym, w nie długim czasie od publikacji tego materiału pojawi się kolejny tym razem dużo mniejszy posty odnośnie podstaw Git-a.
		</p>
		<p>
			Git powinien być już zainstalowany w systemie. Jednak warto się upewnić wydając polecenie:
		</p>
<pre class="code-block">
$ git --version
</pre>
<pre class="code-block">
git version 2.25.1
</pre>
		<p>
			Jeśli dostaniemy taki wynik polecenie, oznacza to że Git jest już zainstalowany w systemie. Instalacja na Ubuntu wymaga jednego polecenia:
		</p>
<pre class="code-block">
$ sudo apt install git
</pre>
		<p>
			Teraz możemy przejść do konfiguracji, musimy podać nazwę użytkownika oraz adres e-mail, który dokonuje zatwierdzeń, ponieważ Git to monitoruje, jeśli zapomnimy o tym kroku, Git będzie wymagał podania tych danych przy pierwszym przesłaniu kodu do zdalnego repozytorium na platformie Heroku.
		</p>
<pre class="code-block">
$ git config --global user.name "xf0r3m"
$ git config --global user.email "morketsmerke@gmail.com"
</pre>
		<p>
			Po skonfigurowaniu gita możemy utworzyć puste repozytorium w katalogu z danymi projektu wydając bardzo proste polecenie
		</p>
<pre class="code-block">
python/django3 $ git init
</pre>
		<p>
			Powinniśmy dostać taki wyniki działania dla tego polecenia:
		</p>
<pre class="code-block">
Initialized empty Git repository in /home/xf0r3m/python/django3/.git/
</pre>
		<p>
			Teraz dodamy plik, w którym zdefiniujemy wszystkie pliki/katalogi, które mają być ignorowane przez Git podczas dodawania zmian do repozytorium. Tworzymy plik <em>.gitignore</em>, plik ten będzie ukryty z powodu kropki poprzedzającej nazwę pliku. W tym pliku wpisujemy katalog środowiska wirtualnego <em>blog_env/</em>, katalog <em>__pycache__/</em> oraz wszystkie pliki baz danych <em>*.sqlite3</em>. Dlaczego?<strong> Otóż monitowanie plików lokalnej bazy danych jest generalnie złą praktyką i może doprowadzić do niezłych tarapatów, kiedy np. nadpiszemy bazę produkcyjną tą na platformie Heroku, bazą testową z Git-a. Dlatego pomijamy ten plik.</strong> Poniżej znajduje się zawartość pliku <em>.gitignore</em>
		</p>
<pre class="code-block">
	blog_env/
__pycache__/
*.sqlite3
</pre>
		<p>
			Teraz kiedy mamy już zdefiniowany plik <em>.gitignore</em>, możemy przejść do pierwszego zatwierdzenia. W katalogu projektu wydajemy polecenie
		</p>
<pre class="code-block">
$ git add .
</pre>
		<p>
			To polecenie doda do repozytorium wszystkie pliki projektu poza plikami i katalogami z pliku <em>.gitignore</em>.
		</p>
<pre class="code-block">
$ git commit -am "Projekt gotowy do wdrożenia na platformie Heroku"
</pre>
		<p>
			Powyższe polecenie powoduje właśnie zatwierdzenie. Opcja <code class="code-inline">-a</code> powoduje uzwględnienie wszystkich zmodyfikowanych plików do zatwierdzenia, natomiast opcja <code class="code-inline">-m</code> powoduje dodanie komunikatu do zatwierdzenia.
		</p>
		<p>
			Po wydaniu powyższego polecenia warto wydać polecenie:
		</p>
<pre class="code-block">
$ git status
</pre>
		<p>
			Aby sprawdzić stan wykonanego zatwierdzania, wynik działania polecenia powinien wyglądać podobnie jak poniżej.
		</p>
<pre class="code-block">
$ git status
On branch master
nothing to commit, working tree clean
</pre>
		<p>Po wykonaniu pierwszego zatwierdzenia przyszedł czas na przekazanie projektu do Heroku. Teraz musimy przypomnieć sobie adres e-mail, na jaki zakładaliśmy konto Heroku oraz jakie było do niego hasło. Jeśli mamy już te dane w pobliżu wydajemy polecenie
		</p>
<pre class="code-block">
python/django3 $ heroku login
heroku: Press any key to open up the browser to login or q to exit:
Logging in... done
Logged in as user@example.com
</pre>
		<p>
			Po wydaniu powyższego polecenia, zgodnie z instrukcją naciskamy dowolny klawisz poza literą <code class="code-inline">q</code>, aby otworzyła nam się przeglądarka. Tam podajemy dane dostępowe do Heroku, po poprawny zalogowaniu, zostanie wyświetlony komunikat o poprawyn zalogowaniu oraz o tym że możemy już zamknąć okno przeglądarki. W terminalu pod instrukcją wyświetloną przez polecenie, zostaną dopisane pozostałe dwie linie takie jak przedstawione powyżej.
		</p>
		<p>
			Po zalogowaniu możemy już utworzyć nową aplikację wydając w terminalu poniższe polecenie.
		</p>
<pre class="code-block">
python/django3 $ heroku create
Creating app... done, ⬢ dry-atoll-67152
https://dry-atoll-67152.herokuapp.com/ | https://git.heroku.com/dry-atoll-67152.git
</pre>
		<p>
			W odpowiedzi na to polecenie otrzymamy nazwę nowo utworzonej aplikacji na Heroku, potem zmienimy ją na bardziej przystępną, oraz dwa adresy. Jeden pod którym aplikacja jest dostępna w internecie, natomiast drugi to adres zdalnego repozytorium Git, na który będziemy <strong>wpychać</strong> zatwierdzenia kodu naszej aplikacji. Adres Git dla naszej aplikacji Heroku został już automatycznie zdefiniowany jako adres zdalnego repozytorium pod nazwą <code class="code-inline">heroku</code>. Dokonajmy teraz pierwszego wepchnięcia oraz zbudujmy naszą aplikacje na platformie Heroku. Budowa następuje automatycznie po wepchnięciu.
		</p>
<pre class="code-block">
python/django3 $ git push heroku master
</pre>
		<p>
			Po wydaniu tego polecenia na ekranie zostanie wyświetlony cały proces budowania aplikacji w Heroku.
		</p>
<pre class="code-block">
Enumerating objects: 46, done.
Counting objects: 100% (46/46), done.
Delta compression using up to 4 threads
Compressing objects: 100% (39/39), done.
Writing objects: 100% (46/46), 9.12 KiB | 1.14 MiB/s, done.
Total 46 (delta 6), reused 0 (delta 0)
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----&gt; Python app detected
remote:  !     Python has released a security update! Please consider upgrading to python-3.8.5
remote:        Learn More: https://devcenter.heroku.com/articles/python-runtimes
remote: -----&gt; Installing python-3.8.2
remote: -----&gt; Installing pip 20.1.1, setuptools 47.1.1 and wheel 0.34.2
remote: -----&gt; Installing SQLite3
remote: -----&gt; Installing requirements with pip
remote:        Collecting asgiref==3.2.10
remote:          Downloading asgiref-3.2.10-py3-none-any.whl (19 kB)
remote:        Collecting beautifulsoup4==4.9.1
remote:          Downloading beautifulsoup4-4.9.1-py3-none-any.whl (115 kB)
remote:        Collecting dj-database-url==0.5.0
remote:          Downloading dj_database_url-0.5.0-py2.py3-none-any.whl (5.5 kB)
remote:        Collecting Django==3.1
remote:          Downloading Django-3.1-py3-none-any.whl (7.8 MB)
remote:        Collecting django-bootstrap4==2.2.0
remote:          Downloading django_bootstrap4-2.2.0-py3-none-any.whl (24 kB)
remote:        Collecting django-heroku==0.3.1
remote:          Downloading django_heroku-0.3.1-py2.py3-none-any.whl (6.2 kB)
remote:        Collecting gunicorn==20.0.4
remote:          Downloading gunicorn-20.0.4-py2.py3-none-any.whl (77 kB)
remote:        Collecting psycopg2==2.8.5
remote:          Downloading psycopg2-2.8.5.tar.gz (380 kB)
remote:        Collecting pytz==2020.1
remote:          Downloading pytz-2020.1-py2.py3-none-any.whl (510 kB)
remote:        Collecting soupsieve==2.0.1
remote:          Downloading soupsieve-2.0.1-py3-none-any.whl (32 kB)
remote:        Collecting sqlparse==0.3.1
remote:          Downloading sqlparse-0.3.1-py2.py3-none-any.whl (40 kB)
remote:        Collecting whitenoise==5.2.0
remote:          Downloading whitenoise-5.2.0-py2.py3-none-any.whl (19 kB)
remote:        Building wheels for collected packages: psycopg2
remote:          Building wheel for psycopg2 (setup.py): started
remote:          Building wheel for psycopg2 (setup.py): finished with status 'done'
remote:          Created wheel for psycopg2: filename=psycopg2-2.8.5-cp38-cp38-linux_x86_64.whl size=483298 sha256=7daad67c78674aaee0b224f104bccb4ab6a0dbc40682c37b80f6f6e5572f5f7e
remote:          Stored in directory: /tmp/pip-ephem-wheel-cache-105idbzs/wheels/35/64/21/9c9e2c1bb9cd6bca3c1b97b955615e37fd309f8e8b0b9fdf1a
remote:        Successfully built psycopg2
remote:        Installing collected packages: asgiref, soupsieve, beautifulsoup4, dj-database-url, pytz, sqlparse, Django, django-bootstrap4, whitenoise, psycopg2, django-heroku, gunicorn
remote:        Successfully installed Django-3.1 asgiref-3.2.10 beautifulsoup4-4.9.1 dj-database-url-0.5.0 django-bootstrap4-2.2.0 django-heroku-0.3.1 gunicorn-20.0.4 psycopg2-2.8.5 pytz-2020.1
soupsieve-2.0.1 sqlparse-0.3.1 whitenoise-5.2.0
remote: -----&gt; $ python manage.py collectstatic --noinput
remote:        132 static files copied to '/tmp/build_f49f7b9a/staticfiles', 418 post-processed.
remote:
remote: -----&gt; Discovering process types
remote:        Procfile declares types -&gt; web
remote:
remote: -----&gt; Compressing...
remote:        Done: 56.1M
remote: -----&gt; Launching...
remote:        Released v5
remote:        https://dry-atoll-67152.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/dry-atoll-67152.git
 *[new branch]      master -&gt; master
</pre>
		<p>
			Jeśli otrzymaliśmy podobny input, to znaczy że cały proces przebiegł prawidłowo. Teraz jeśli wydamy polecenie:
		</p>
<pre class="code-block">
python/django3 $ heroku open
</pre>
		<p>
			Zostanie otworzona przeglądarka z nasza aplikacją w Heroku. Jednak, jeśli klikniemy w odnośnik 'Menu', zostanie nam zrócona strona błedu <em>ProgrammingError</em>, oznacza to mniej więcej tyle i aż tyle że nie ma bazy danych. Utworzenie bazy danych oraz dodanie superużytkownika, to dwie kolejne czynności, które możemy wykonać dwa różne sposoby przedstawie je poniżej, aby byśmy zwrócili uwagę na to że z aplikacjami na Heroku można wchodzić w interakcje w dwojaki sposób. Pierwszy z nich to wydawanie konkretnych poleceń <strong>poprzedzając nasze polecenie słowami <code class="code-inline">heroku run</code></strong>. Uruchamiamy daną czynność tak samo jak w środowisku wirtualnym na naszym lokalnym komputerze. Tak też stworzymy bazę danych.
		</p>
<pre class="code-block">
python/django3 $ heroku run python manage.py migrate
Running python manage.py migrate on ⬢ dry-atoll-67152... up, run.7671 (Free)
Operations to perform:
  Apply all migrations: admin, auth, blogs, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying blogs.0001_initial... OK
  Applying blogs.0002_blogpost_owner... OK
  Applying sessions.0001_initial... OK
</pre>
		<p>
			Jak można zauważyć na początku trwa nawiązywanie połączenia z naszym kontenerem (naszą aplikacją), a następnie wykonywane jest polecenie. Drugim sposobem jest uruchomienie <strong>powłoki w środowisku kontenera Heroku</strong>, za pomocą tej metody utworzymy superużytkownika. Aby uruchomić powłokę  należy wydać następujące polecenie.
		</p>
<pre class="code-block">
python/django3 $ heroku run bash
Running bash on ⬢ dry-atoll-67152... up, run.8503 (Free)
~ $
</pre>
		<p>
			Po połączeniu zostanie na zrócony taki charakterystyczny, krótki znak zachęty. Zaraz zanim wydajemy polecenie, takie jakie wydawaliśmy podczas tworzenie superużytkownika na naszym komputerze.
		</p>
<pre class="code-block">
~ $ python manage.py createsuperuser
Użytkownik (leave blank to use 'u17122'): blog_admin
Adres email:
Password:
Password (again):
Superuser created successfully.
</pre>
		<p>
			Teraz możemy przjeść do naszej aplikacji oraz móc sprawdzić moduł logowania oraz zalogować się do witryny administracyjnej aby zdefiniować trochę danych.
		</p>
		<p>
			Teraz kiedy nasza aplikacja jest gotowa, możemy przjeść do nadania jej nieco przyjaźniejszej nazwy. Zmianę nazwy realizujemy za pomocą polecenia:
		</p>
<pre class="code-block">
python/django3 $ heroku apps:rename blogs-morkme-v01
</pre>
		<p>
			<strong>Pamiętać jednak należy o tym że podczas nadawania nazw w Heroku możemy korzystać jedynie z liter, cyfr oraz myślników</strong>.
		</p>
		<p>
			Teraz przejdziemy do zabepieczenia naszej aplikacji. Zwróćmy uwagę na to że gdy w plikach naszego projektu na Heroku zabrakło bazy danych, <strong>została na zwrócona strona z opisem błędu </strong><em><strong>ProgrammingError</strong></em><strong>, ta strona została przygotowana przez Debuger.</strong> W środowisku testowym jest powszechne i często spotykane zjawisko, że w razie błędów zostanie wyświetlona strona z informacjami o tym gdzie szukać danego błędu, jednak w środowisku produkcyjnym takim jak Heroku jest to niedopuszczalne, takie strony zazwyczaj zwracają za dużo newralgicznych danych i mogą być wykorzystane do ataków przeciwko nam. Na podstawie zmiennej środowiskowej będziemy regulować wyświetlanie stron debugera. Z racji tego iż<strong> w Django zmienna Debug przyjmuje wartość boolowską, a z kolei zmienne środowiskowe przechowują ciągi tekstowe</strong>, będzie nam potrzebna konstrukcja if, którą zaimplementujemy w pliku <em>settings.py</em> w głównym katalogu projektu.
		</p>
		<p>
			Naszą implementacje zaczynamy od zaimportowania obiektu <code class="code-inline">environ</code> modułu <code class="code-inline">os</code> na górze pliku. Następnie na samym dole pliku wprowadzamy poniższy kod.
		</p>
<pre class="code-block">
if environ.get('DEBUG') == 'TRUE':
    DEBUG = True
elif environ.get('DEBUG') == 'FALSE':
    DEBUG = False
</pre>
		<p>
			Za pomocą metody <code class="code-inline">get</code> obiektu <em>environ</em>, pobieramy wartość zmiennej środowiskowej, której nazwa jest pobierana jako ciąg tekstowy w pierwszym argumencie. W zależności od wyniku przyrównania wartości w zmiennej <code class="code-inline">DEBUG</code> nadawana jest wartość boolowska <code class="code-inline">True</code> or <code class="code-inline">False</code>. Z racji tego iż przesłaliśmy plik <em>settings.py</em>, wraz ustawioną opcją <em>DEBUG</em> na <em>True</em>. To teraz musimy ją zmienić w naszej aplikacji na platformie Heroku, możemy tego dokonać za pomocą jednego polecenia.
		</p>
<pre class="code-block">
python/django3 $ heroku config:set DEBUG=FALSE
</pre>
		<p>
			<strong>To polecenie spowoduje ustawienie podanej zmiennej środowiskowej na podaną wartość oraz restart aplikacji</strong>. Teraz otworzymy naszą aplikację za pomocą polecenia <code class="code-inline">heroku open</code> i przejdziemy pod stronę, której nie zaimplementowano w naszej aplikacji. Powinniśmy otrzymać typowy komunikat <em>Not Found</em>. Ten komunikat nie pasuje do szaty graficznej naszej aplikacji, my jednak możemy dodać własne szablony dla typowych błędów. Szablony będą banalne, ale będą miały jedną ważną cechę. Będą ładować podstawowy wygląd naszej aplikacji. Zaczynamy od utworzenia katalogu <em>templates</em> w głównym katalogu projektu. W tym katalogu tworzymy dwa pliki: <em>404.html</em> oraz <em>500.html</em>. Poniżej zamieszczam zawartość każdego szablonu.
		</p>
		<p>
			<span style="text-decoration: underline;">Plik 404.html</span>
		</p>
<pre class="code-block">
{% extends 'blogs/base.html' %}

{% block page_header %}
    &lt;h2&lt;Żądana strona nie zostałą odnaleziona (404).&lt;/h2&gt;
{% endblock page_header %}
</pre>
			<p>
				<span style="text-decoration: underline;">Plik 500.html</span>
			</p>
<pre class="code-block">
{% extends 'blogs/base.html' %}

{% block page_header %}
    &lt;h2&gt;Wystąpił wewnętrzny błąd serwera (500).&lt;/h2&gt;
{% endblock page_header %}
</pre>
		<p>
			Teraz wracamy do naszego pliku <em>settings.py</em> w nim ustawiamy jedną rzecz. Na początku importujemy obiekt <em>path</em> z modułu <em>os</em>. Następnie odszukujemy klucz <em>DIRS</em> w słowniku wenątrz listy <em>TEMPLATES</em>. Następnie wewnątrz listy DIRS wpisujemy jedną wartość zwracaną przez metodę <em>join</em> obiektu <em>path</em>, która jako argumenty przyjmuje ścieżkę bazową <em>BASE_DIR</em> oraz ścieżkę dostępu do szablonów względem ścieżki bazowej. Trochę to zagmatwane, ale jak spojrzymy w górę kodu dostrzerzemy fakt iż <em>BASE_DIR</em> to zmienna, którą możemy sobie odtworzyć w powłoce. Jako<em>__file__</em> podstawimy ścieżke do dostępową do pliku <em>settings.py</em> względem naszego katalogu głównego z plikami, gdzie znajdują katalog projektu, katalogi aplikacji oraz katalog ze środowiskiem wirtualnym.
			<span style="text-decoration: underline;"></span>Poniżej zamieściłem listing z konsoli jak możemy sprawdzić naszą ścieżkę.
		</p>
<pre class="code-block">
&gt;&gt;&gt;from pathlib import Path
&gt;&gt;&gt; base_dir = Path('blog/settings.py').resolve(strict=True).parent.parent
&gt;&gt;&gt; base_dir
PosixPath('/home/xf0r3m/python/django3')
</pre>
		<p>
			Teraz znając już wartość naszej zmiennej <em>BASE_DIR</em> możemy perfekcyjnie ustalić ścieżke dostępową do naszych szablonów.
		</p>
		<p>
			Warto pamiętać o tym że te szablony będą wyświetlane tylko wtedy, gdy opcja <em>DEBUG</em> jest ustawiona na False. Możemy je przetestować żądając strony, której nie ma, otrzymamy stronę błędu 404. Natomiast jeśli spróbujemy edytować zamówienie, którego niema to w ten czas otrzymamy stronę błędu 500. Skupmy się przez chwilę na tym drugim przypadku, kiedy chcemy edytować zamowienie, którego nie ma. Przezkazujemy za pomocą metody <em>GET</em> identyfikator zamówienia, kiedy widok próbuje wydobyć informacje odnośnie rekordu o takim identyfikatorze otzymuje wartość <em>None</em>, oznacza to tyle że nie ma takiego rekordu, jeśli więc nie ma takiego rekordu to żądana strona edycji zamówienia nie może istnieć, więc lepiej użyć strony 404 niż 500.
			Można to zrealizować wykorzystując funkcję <code class="code-inline">get_object_or_404</code> z tego samego modułu <code class="code-inline">django.shortcuts</code>, z którego importowaliśmy funkcje render oraz redirect, następnie możemy jej użyć w każdym widoku wymagającym identyfikatora np. w zapytaniach do bazy.
		</p>
<pre class="code-block">
# order = Order.objects.get(id=order_id)
order = get_object_or_404(Order, id=order_id)
</pre>
		<p>
			Zbliżamy się do końca tej ściągi, jednak zanim się rozejdziemy dalej poznawać świat Pythona, posprzątamy po sobie. Jednak jeśli chcesz możesz w ramach ćwiczenia rozwinąć projekt Pizzeria do stanu użytczeności.
		</p>
		<p>
			Jednak jeśli ta aplikacja, która była z nami przez dłuższą część nauki frameworka Django przestała być potrzebna, to możemy ją usunąć z platformy wydajac polecenie:
		</p>
<pre class="code-block">
python/django2 $ heroku apps:destroy pizzeria-morkme-1a
 ▸    WARNING: This will delete ⬢ pizzeria-morkme-1a including
 ▸    all add-ons.
 ▸    To proceed, type pizzeria-morkme-1a or re-run this
 ▸    command with --confirm pizzeria-morkme-1a
 &gt;
</pre>
		<p>
			Heroku zarząda od nas potwierdzenia, w postaci ponownego wprowadzenia nazwy aplikacji. Po jej podaniu, otrzymamy informacje poprawnym <strong>zniszczeniu</strong> aplikacji na platformie Heroku.
		</p>
<pre class="code-block">
&gt; pizzeria-morkme-1a
Destroying ⬢ pizzeria-morkme-1a (including all add-ons)... done
</pre>
		<p>
			Jeśli chodzi o podstawy Pythona oraz Django to wydaje mi się że mamy je już za sobą. Przez bardzo długi czas bo ponad dwa miesiąc pisał dla was:
		</p>
		<p>
			~xf0r3m
		</p>
	</div>
	<p style="margin: 15px; padding: 0; outline: 0;">
		2021; COPYLEFT; ALL RIGHT REVERSED;
	</p>
		</body>
	</html>
